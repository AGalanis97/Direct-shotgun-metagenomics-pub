"0","```r


new_genus1 <- as.data.frame(t(Genus_clr))
Hive_new <- new_genus1 %>% dplyr::select(.,c(\"DirectSM_H7\",\"SM_H7\"))
wilcox.test(Hive_new$DirectSM_H7,Hive_new$SM_H7,paired = TRUE, alternative = \"greater\")















Hive_4_Genus <- column_to_rownames(Hive_4, \"Taxonomic_ID\")
Hive_4_an <- data.frame(Hive_4_Genus[which(apply(Hive_4_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_5_Genus <- column_to_rownames(Hive_5, \"Taxonomic_ID\")
Hive_5_an <- data.frame(Hive_5_Genus[which(apply(Hive_5_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_6_Genus <- column_to_rownames(Hive_6, \"Taxonomic_ID\")
Hive_6_an <- data.frame(Hive_6_Genus[which(apply(Hive_6_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_7_Genus <- column_to_rownames(Hive_7, \"Taxonomic_ID\")
Hive_7_an <- data.frame(Hive_7_Genus[which(apply(Hive_7_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

conditions <- c(\"Direct_SM\",\"SM\")

x_distr4 <- aldex.clr(Hive_4_an, conditions, mc.samples=128, verbose=TRUE)
x.tt4 <- aldex.ttest(x_distr4, conditions, paired.test=TRUE)
x.effect4 <- aldex.effect(x_distr4, conditions, verbose=TRUE)
x.all4 <- data.frame(x.tt4, x.effect4, stringsAsFactors=FALSE)

png(\"Genus_all_MA.png\", width = 5, height = 5, units = \"in\", res = 300)
aldex.plot(x.all4, type=\"MA\", test=\"welch\")
dev.off()

png(\"Genus_all_MW.png\", width = 5, height = 5, units = \"in\", res = 300)
aldex.plot(x.all4, type=\"MW\", test=\"welch\")
dev.off()



sig.op <- rownames(x.all4)[which(x.all4$we.eBH < 0.05 & x.all4$effect > 1)]

# What are the taxa that are significantly different?
# Using the OTU names, we can get the taxonomy from our taxon table
taxon[sig.op,]

# We can also look at the ALDEx output for the significant OTUs
x.all[sig.op,]


colours <- c(\"indianred1\", \"steelblue3\",  \"skyblue1\", \"mediumorchid\",\"royalblue4\", \"olivedrab3\",
   \"pink\", \"#FFED6F\", \"mediumorchid3\", \"ivory2\", \"tan1\", \"aquamarine3\", \"#C0C0C0\",
    \"mediumvioletred\", \"#999933\", \"#666699\", \"#CC9933\", \"#006666\", \"#3399FF\",
   \"#993300\", \"#CCCC99\", \"#666666\", \"#FFCC66\", \"#6699CC\", \"#663366\", \"#9999CC\", \"#CCCCCC\",
   \"#669999\", \"#CCCC66\", \"#CC6600\", \"#9999FF\", \"#0066CC\", \"#99CCCC\", \"#999999\", \"#FFCC00\",
   \"#009999\", \"#FF9900\", \"#999966\", \"#66CCCC\", \"#339966\", \"#CCCC33\", \"#EDEDED\"
)


x_no_2 <- aldex.clr(d.5_no, mc.samples=128, verbose=TRUE)
































propr.clo <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop(\"negative values found\")
    if(any(is.na(X))) stop(\"NA values found\")
  }
  return(sweep(X, 1, rowSums(X), \"/\"))
}

propr.clr <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop(\"negative values found\")
    if(any(is.na(X))) stop(\"NA values found\")
  }
  logX <- log(X)
  return(sweep(logX, 1, rowMeans(logX), \"-\"))
}

propr.vlr <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop(\"negative values found\")
    if(any(is.na(X))) stop(\"NA values found\")
  }
  logX <- log(X)
  Cov    <- stats::var(logX)  ## Note the avoidance of compositions::var
  D      <- ncol(logX)
  VarCol <- matrix(rep(diag(Cov), D), ncol = D)
  return(-2 * Cov + VarCol + t(VarCol))
}

propr.phisym <- function (X)
{
  Cov    <- stats::var(X)
  tmp    <- 2 * Cov / outer(diag(Cov), diag(Cov), \"+\")
  return((1-tmp)/(1+tmp))
}

propr.aldex.phi <- function(aldex.clr, return=\"df\"){

	# calculate expected value of phi
	# a single high phi value will push the component out of consideration
	# a median is right out for memory considerations

	# get first value
	sym.phi <- propr.phisym(t(sapply(getMonteCarloInstances(aldex.clr),
	    function(y){y[,1]})))

	# sum the rest of the values as we proceed through the DIR MC instances
	for(i in 2:numMCInstances(aldex.clr)){
		#print(i)
		sym.phi <- sym.phi + propr.phisym(t(sapply(getMonteCarloInstances(aldex.clr),
		    function(y){y[,i]})))
	}
	##### Done ALDEx2 stuff

	# make indices of the correct size
	lt <- which(col(sym.phi)<row(sym.phi), arr.ind=FALSE)
	lt.ind <- which(col(sym.phi)<row(sym.phi), arr.ind=TRUE)

	# dataframe to hold the info,
	# data is a set of vectors where only the lower triangle is kept, because the matrix
	#    is symmetrical
	# this is needed so subsequent subset function works properly
	sma.df <- data.frame(row=factor(rownames(sym.phi)[lt.ind[,\"row\"]]),
		col=factor(colnames(sym.phi)[lt.ind[,\"col\"]]))

	#save the lower triangle as an expected value
	sma.df$phi <- sym.phi[lt] /  numMCInstances(aldex.clr)

	if(return==\"df\") return(sma.df)
	if(return==\"mat\") return(sym.phi /  numMCInstances(aldex.clr))
}

d.sma.df <- propr.aldex.phi(x_no_2)

phi.cutoff <- 0.25

# get the subset of OTUs that are joined by one or more low phi connections
d.sma.lo.phi <- subset(d.sma.df, phi < phi.cutoff)

g <- graph.data.frame(d.sma.lo.phi, directed=FALSE)

# igraph: find the clusters
g.clust <- clusters(g)

# make a table to examine the cluster membership by hand
g.df <- data.frame(Systematic.name=V(g)$name, cluster=g.clust$membership, 
    cluster.size=g.clust$csize[g.clust$membership])

# generate a set of clusters larger than some size # minimum is 2 (obviously)
big <- g.df[which(g.df$cluster.size >= 2),] 
colnames(big) <- colnames(g.df)

# igraph: rename the cluster members by their genus name
# gsub(pattern, replacement, strings, perl-syntax)
V(g)$name <- gsub(\"(^[A-Za-z]{3}).+\", \"\\1\", as.vector(taxon[names(V(g)),\"genus\"]), 
    perl=TRUE)

# igraph:
# vertex.size controls point and text color
# vertex.color controls point color
# vertex.frame controls point outline color
png(\"network.png\")
plot(g, vertex.size=2, vertex.color=rgb(0,0,0,0.2), vertex.frame.color=\"white\")
dev.off()

```"
