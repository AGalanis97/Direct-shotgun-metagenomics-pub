---
title: "R Notebook"
output: html_notebook
---

Including Hive 7
```{r}
install.packages('devtools')
BiocManager::install("ALDEx2")

devtools::install_github('ggloor/CoDaSeq/CoDaSeq')
```


```{r}
setwd("C:/Users/user/Desktop/data_frames/comparison")
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('taxonomizr')) install.packages('taxonomizr'); library('taxonomizr')
library(tidyverse)
library(dplyr)

data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"

# Vector with the column names of the kraken2 output
kraken2_output_names <- c("Reads_assigned_rooted_at_taxon", "Reads_assigned_directly_to_taxon","Rank_code","Taxonomic_ID","Name")

# Import the kraken2 output
import_kraken2_files <- list.files(path = data_path,pattern = "\\.kraken2",full.names = T)

kraken2_files <- lapply(import_kraken2_files, function(tble) {
  read.delim(file = tble, 
             sep = '\t',
             header = FALSE,
             strip.white = TRUE)[,-c(1)]
})

naming_list <- list.files(path = data_path,pattern = "\\.kraken2")

# This will name each element (or dataframe) of the list
# according to the filename it originated from.

kraken2_files <- setNames(kraken2_files, substring(naming_list, first  = 1, last = nchar(naming_list) -8))

kraken2_files = lapply(kraken2_files,setNames,kraken2_output_names)

kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)


# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
  taxids <- df[,4]
  Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
  Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
  Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
  cbind(df, Phylum, Kingdom, Superkingdom)
}

kraken2_files = lapply(kraken2_files, classification_ranks)


```

Now that we have loaded our data, we can simply filter it with dplyr to get the new lists that we want. We create new lists for family (F), genus (G), and species (S). For each taxonomic level we remove the contaminants belonging to 'Drosophila'. Note that the contaminants belonging to 'Homo sapiens' are not removed at this step. Then, we extract the columns containing the taxonomic ID and the number of reads. Note that for genus and family we use the _Sample_reads_rooted_at_taxon_ . Lastly, for each taxonomic level, we create a new dataframe that has merged the data across the samples. The entire clade of 'Chordata' is removed at this step which includes 'Homo sapiens' as well as all of the chordates which likely represent misclassified contaminants.

```{r}
kraken2_files_family <- kraken2_files %>% lapply(filter, Rank_code == "F") %>% lapply(filter, Name != "Drosophilidae") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_genus <- kraken2_files %>% lapply(filter, Rank_code == "G") %>% lapply(filter, Name != "Drosophila") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")

kraken2_files_species <- kraken2_files %>% lapply(filter, Rank_code == "S") %>% lapply(filter, Name != "Drosophila melanogaster") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")


kraken2_files_filter_genus <- lapply(kraken2_files_genus, "[", c(2,4))
kraken2_files_filter_species <- lapply(kraken2_files_species, "[", c(2,4))
kraken2_files_filter_family <- lapply(kraken2_files_family, "[", c(1,4))


Hives_genus <- lapply(names(kraken2_files_filter_genus), function(x){
  colnames(kraken2_files_filter_genus[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_genus[[x]]
})
names(Hives_genus) <- names(kraken2_files_filter_genus) 

Hives_species <- lapply(names(kraken2_files_filter_species), function(x){
  colnames(kraken2_files_filter_species[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_species[[x]]
})
names(Hives_species) <- names(kraken2_files_filter_species) 


Hives_family <- lapply(names(kraken2_files_filter_family), function(x){
  colnames(kraken2_files_filter_family[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_family[[x]]
})
names(Hives_family) <- names(kraken2_files_filter_family) 


Hives_comparison_genus <- Hives_genus %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.),0))

Hives_comparison_species <- Hives_species %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))


Hives_comparison_family <- Hives_family %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))

```


```{r}

library(zCompositions)

Genus_all <- Hives_comparison_species


rownames(Genus_all) <- c()

Genus_all <- column_to_rownames(Genus_all, "Taxonomic_ID")

Genus <- data.frame(Genus_all[which(apply(Genus_all, 1, function(x){sum(x)}) > 1),], check.names=F)

classification_clr <- function(df) {
  taxids <- rownames(df)
  Species <- as.character(getTaxonomy(taxids,desiredTaxa = "species",'nameNode.sqlite'))
}


Genus_czm <- cmultRepl(t(Genus),  label=0, method="CZM")

Genus_clr <- t(apply(Genus_czm, 1, function(x){log(x) - mean(log(x))}))

Genus_pcx <- prcomp(Genus_clr, scale. = F)

vargenus <- get_pca_var(Genus_pcx)

cos2genus <- vargenus$cos2 %>% as.data.frame()

xgenus <- cos2genus[order(cos2genus$Dim.1),] # create a vector and sort with the hightest values of the column on the top
species_dim1 <- rownames(xgenus) %>% as.numeric()
top30_dim1 <- species_dim1[1:30]

xgenus_dim2 <- cos2genus[order(cos2genus$Dim.2),] # create a vector and sort with the hightest values of the column on the top
species_dim2 <- rownames(xgenus_dim2) %>% as.numeric()
top30_dim2 <- species_dim2[1:30]

top30_dim1_and_dim2 <- c(top30_dim1,top30_dim2)
top30_removed_dupl <- top30_dim1_and_dim2[!duplicated(top30_dim1_and_dim2)]

trial_pcx <- Genus_pcx
filtered_pcx <- Genus_pcx$rotation %in% top30_removed_dupl

annotationrows_species <- bind_cols(Taxid_taxonomy_species,Taxonomic_IDs_dataframe_species,generate_species)
colnames(annotationrows_species) <- c("Domain", "Taxonomic_ID","Species")

annotationrows_species_2 = annotationrows_species[,-2]
annotationrows_species_clr <- tibble::column_to_rownames(annotationrows_species_2, var = "Species")

species_colours <- annotationrows_species_clr %>% rownames_to_column(var = "Species")
species_colours1 <- filter(species_colours, Species %in% Genus_names1$Genus_names)

get_super_kingdom_or_plant <- function(x) {
  setwd(getwd())
  ifelse(getTaxonomy(x, desiredTaxa = "superkingdom", 'nameNode.sqlite') != "Eukaryota", getTaxonomy(x, desiredTaxa = "superkingdom", 'nameNode.sqlite'), ifelse(getTaxonomy(x, desiredTaxa = "kingdom", 'nameNode.sqlite') == "Viridiplantae", getTaxonomy(x, desiredTaxa = "kingdom",'nameNode.sqlite'), getTaxonomy(x, desiredTaxa = "superkingdom", 'nameNode.sqlite')))
}


TaxonomicIDs_genus <- as.numeric(rownames((Genus)))
Taxid_taxonomy_genus <- as.data.frame(get_super_kingdom_or_plant(TaxonomicIDs_genus)) 
Taxonomic_IDs_dataframe_genus <- as.data.frame(TaxonomicIDs_genus)
annotationrows_genus <- bind_cols(Taxid_taxonomy_genus,Taxonomic_IDs_dataframe_genus)
colnames(annotationrows_genus) <- c("Domain", "Taxonomic_ID")
annotationrows_genus <- tibble::column_to_rownames(annotationrows_genus, var = "Taxonomic_ID")

Genus_names <- classification_clr(Genus)
Genus_names1 <- as.data.frame(Genus_names)
Genus_names1$Genus_names <- as.character(Genus_names1$Genus_names)
Genus_names1[911,1] <- print("Acinetobacter sp. NEB149")
Genus_names1[638,1] <- print("Mesorhizobium sp. NIBRBAC000500504")

Genus_copy <- Genus

rownames(Genus_copy) <- NULL
rownames(Genus_copy) <- Genus_names1[,1] 

rownames(annotationrows_genus) <- NULL
rownames(annotationrows_genus) <- rownames(Genus_copy)

factoextra::fviz_pca_biplot(Genus_pcx,repel = T, select.var = list(contrib = 15), col.var = annotationrows_genus$Domain)


Genus_mvar <- sum(Genus_pcx$sdev^2)
# Calculate the PC1 and PC2 variance

PC1 <- paste("PC1: ", (round(sum(Genus_pcx$sdev[1]^2)/Genus_mvar, 3))*100, "%")
PC2 <- paste("PC2: ", (round(sum(Genus_pcx$sdev[2]^2)/Genus_mvar, 3))*100, "%")

# We are pasting together the component name and the variance to make an axes label
# Look at the PC1 variable by typing it in your console

# The basic biplot function:
# Plus we are printing the variance explained on the axes labels (as calculated before)
biplot(Genus_pcx, var.axes=T, scale=0, xlab=PC1, ylab=PC2)


Genus_points <- c(rep(".", length(dimnames(Genus_pcx$rotation)[[1]])))
Genus_names <- which(dimnames(Genus_pcx$rotation)[[1]] %in% top30_removed_dupl)

# Color and text size for labels and points (vector of 2)
#   The first is the sample lables, the second is the points (OTUs). 
col=c("black",rgb(1,0,0,0.2))
size=c(0.5, 2) #Relative scale, 1 is 100%

# Add all the label information into the biplot code
biplot(Genus_pcx, cex=size, col=col, var.axes=T,
    xlab=PC1, ylab=PC2,
    scale=0, ylabs=Genus_points, xlim = c(-30,30)
)


get_taxonomy_pcx <- rownames(Genus_pcx$center)


col.g=c("black",rgb(1,0,0,0.4))
size.g=c(0.5, 0.4)

png("Biplot_Genus.png", width = 5, height = 5, units = "in", res = 300)
biplot(Genus_pcx, cex=size.g, col=col.g, var.axes=F,
    xlab=paste("PC1: ", (round(sum(Genus_pcx$sdev[1]^2)/Genus_mvar, 3))*100, "%"),
    ylab=paste("PC2: ", (round(sum(Genus_pcx$sdev[2]^2)/Genus_mvar, 3))*100, "%"),
    scale=0, xlim = c(-40,40), ylabs = top30_dim1_and_dim2
)
abline(h=0, lty=2, col=rgb(0,0,0,0.1))
abline(v=0, lty=2, col=rgb(0,0,0,0.1))
dev.off()

png("clustering_genus.png", width = 5, height = 5, units = "in", res = 300)
hc <- hclust(dist(Genus_clr))
plot(hc, hang=-1)
dev.off()

```

Without Hive 7
```{r message=FALSE}
setwd("C:/Users/user/Desktop/data_frames/comparison/No_Hive7")

kraken2_output_names <- c("Sample_rooted_reads", "Sample_reads","Rank_code","Taxonomic_ID","Name")

import_kraken2_files_no_Hive7 <- list.files(path = "C:/Users/user/Desktop/data_frames/comparison/No_Hive7",pattern = "\\.tsv",full.names = T)

kraken2_files_no_Hive7 <- lapply(import_kraken2_files_no_Hive7, function(tble) {
   read.delim(file = tble, 
              sep = '\t',
              header = FALSE,
              strip.white = TRUE)[,-c(1)]
})

naming_list_no_Hive7 <- list.files(path = "C:/Users/user/Desktop/data_frames/comparison/No_Hive7",pattern = "\\.tsv")

# This will name each element (or dataframe) of the list
# according to the filename it originated from.

kraken2_files_no_Hive7 <- setNames(kraken2_files_no_Hive7, substring(naming_list_no_Hive7, first  = 1, last = nchar(naming_list_no_Hive7) -4))

kraken2_files_no_Hive7 = lapply(kraken2_files_no_Hive7,setNames,kraken2_output_names)

kraken2_files_no_Hive7 = lapply(kraken2_files_no_Hive7,arrange, Taxonomic_ID)

# Optionally add the relative abundance as well
kraken2_files_no_Hive7 = lapply(kraken2_files_no_Hive7, function(df) {
  df$Relative_abundance = df$Sample_reads / df[1,1] * 100;
  df$Relative_abundance_rooted = df$Sample_rooted_reads / df[1,1] * 100;
  return(df)
})

kraken2_files_no_Hive7 = lapply(kraken2_files_no_Hive7, classification_ranks)


kraken2_files_no_Hive7_family <- kraken2_files_no_Hive7 %>% lapply(filter, Rank_code == "F") %>% lapply(filter, Name != "Drosophilidae") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_no_Hive7_genus <- kraken2_files_no_Hive7 %>% lapply(filter, Rank_code == "G") %>% lapply(filter, Name != "Drosophila") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata") 
kraken2_files_no_Hive7_species <- kraken2_files_no_Hive7 %>% lapply(filter, Rank_code == "S") %>% lapply(filter, Name != "Drosophila melanogaster") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")


kraken2_files_filter_no_Hive7_genus <- lapply(kraken2_files_no_Hive7_genus, "[", c(2,4))
kraken2_files_filter_no_Hive7_species <- lapply(kraken2_files_no_Hive7_species, "[", c(2,4))
kraken2_files_filter_no_Hive7_family <- lapply(kraken2_files_no_Hive7_family, "[", c(1,4))


Hives_no_Hive7_genus <- lapply(names(kraken2_files_filter_no_Hive7_genus), function(x){
  colnames(kraken2_files_filter_no_Hive7_genus[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_no_Hive7_genus[[x]]
})
names(Hives_no_Hive7_genus) <- names(kraken2_files_filter_no_Hive7_genus) 

Hives_no_Hive7_species <- lapply(names(kraken2_files_filter_no_Hive7_species), function(x){
  colnames(kraken2_files_filter_no_Hive7_species[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_no_Hive7_species[[x]]
})
names(Hives_no_Hive7_species) <- names(kraken2_files_filter_no_Hive7_species) 

Hives_no_Hive7_family <- lapply(names(kraken2_files_filter_no_Hive7_family), function(x){
  colnames(kraken2_files_filter_no_Hive7_family[[x]]) <- c(x,"Taxonomic_ID")
  kraken2_files_filter_no_Hive7_family[[x]]
})
names(Hives_no_Hive7_family) <- names(kraken2_files_filter_no_Hive7_family) 


Hives_comparison_no_Hive7_genus <- Hives_no_Hive7_genus %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% dplyr::select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.),0))

Hives_comparison_no_Hive7_species <- Hives_no_Hive7_species %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% dplyr::select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))

Hives_comparison_no_Hive7_family <- Hives_no_Hive7_family %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% dplyr::select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))

```


```{r}
library(zCompositions)

Genus_no_Hive7 <- Hives_comparison_no_Hive7_genus 
rownames(Genus_no_Hive7) <- c()

Genus_no_Hive7_all <- column_to_rownames(Genus_no_Hive7, "Taxonomic_ID")

Genus_no_Hive7_all_2 <- data.frame(Genus_no_Hive7_all[which(apply(Genus_no_Hive7_all, 1, function(x){mean(x)}) > 1),], check.names=F)


Genus_no_Hive7_all_2_czm <- cmultRepl(t(Genus_no_Hive7_all_2),  label=0, method="CZM")

Genus_no_Hive7_all_2_clr <- t(apply(Genus_no_Hive7_all_2_czm, 1, function(x){log(x) - mean(log(x))}))

Genus_no_Hive7_all_2_pcx <- prcomp(Genus_no_Hive7_all_2_clr)

Genus_no_Hive7_all_2_mvar <- sum(Genus_no_Hive7_all_2_pcx$sdev^2)
# Calculate the PC1 and PC2 variance

PC1_no <- paste("PC1: ", round(sum(Genus_no_Hive7_all_2_pcx$sdev[1]^2)/Genus_no_Hive7_all_2_mvar, 3))
PC2_no <- paste("PC2: ", round(sum(Genus_no_Hive7_all_2_pcx$sdev[2]^2)/Genus_no_Hive7_all_2_mvar, 3))

col.g=c("black",rgb(1,0,0,0.4))
size.g=c(0.5, 0.4)

png("Biplot_Genus_no_Hive7.png", width = 5, height = 5, units = "in", res = 300)
biplot(Genus_no_Hive7_all_2_pcx, cex=size.g, col=col.g, var.axes=F,
    xlab=paste("PC1: ", round(sum(Genus_no_Hive7_all_2_pcx$sdev[1]^2)/Genus_no_Hive7_all_2_mvar, 3)),
    ylab=paste("PC2: ", round(sum(Genus_no_Hive7_all_2_pcx$sdev[2]^2)/Genus_no_Hive7_all_2_mvar, 3)),
    scale=0, 
)
abline(h=0, lty=2, col=rgb(0,0,0,0.1))
abline(v=0, lty=2, col=rgb(0,0,0,0.1))
dev.off()

png("clustering_no_Hive7.png", width = 5, height = 5, units = "in", res = 300)
hc_Genus_no_Hive7 <- hclust(dist(Genus_no_Hive7_all_2_clr))
plot(hc_Genus_no_Hive7, hang=-1)
dev.off()

```




```{r}
#Only with DSM

Only_DSM_Genus <- Hives_comparison_genus %>% dplyr::select(.,-c("SM_H4","SM_H5","SM_H6","SM_H7"))

rownames(Only_DSM_Genus) <- c()

Only_DSM_Genus <- column_to_rownames(Only_DSM_Genus, "Taxonomic_ID")
Genus_DSM <- data.frame(Only_DSM_Genus[which(apply(Only_DSM_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)


Only_DSM_Genus_czm <- cmultRepl(t(Genus_DSM),  label=0, method="CZM")

Only_DSM_Genus_clr <- t(apply(Only_DSM_Genus_czm, 1, function(x){log(x) - mean(log(x))}))

Only_DSM_Genus_pcx <- prcomp(Only_DSM_Genus_clr)

Only_DSM_Genus_mvar <- sum(Only_DSM_Genus_pcx$sdev^2)
# Calculate the PC1 and PC2 variance

PC1_no <- paste("PC1: ", round(sum(Only_DSM_Genus_pcx$sdev[1]^2)/Only_DSM_Genus_mvar, 3))
PC2_no <- paste("PC2: ", round(sum(Only_DSM_Genus_pcx$sdev[2]^2)/Only_DSM_Genus_mvar, 3))

col.g=c("black",rgb(1,0,0,0.4))
size.g=c(0.5, 0.4)

png("Biplot_Only_DSM_Genus.png", width = 5, height = 5, units = "in", res = 300)
biplot(Only_DSM_Genus_pcx, cex=size.g, col=col.g, var.axes=F,
    xlab=paste("PC1: ", round(sum(Only_DSM_Genus_pcx$sdev[1]^2)/Only_DSM_Genus_mvar, 3)),
    ylab=paste("PC2: ", round(sum(Only_DSM_Genus_pcx$sdev[2]^2)/Only_DSM_Genus_mvar, 3)),
    scale=0, 
)
abline(h=0, lty=2, col=rgb(0,0,0,0.1))
abline(v=0, lty=2, col=rgb(0,0,0,0.1))
dev.off()

png("Only_DSM_Genus_clusstering.png", width = 5, height = 5, units = "in", res = 300)
hc_Only_DSM_Genus <- hclust(dist(Only_DSM_Genus_clr))
plot(hc_Only_DSM_Genus, hang=-1)
dev.off()


Only_SM_Genus <- Hives_comparison_genus %>% dplyr::select(.,-c("DirectSM_H4","DirectSM_H5","DirectSM_H6","DirectSM_H7"))

rownames(Only_SM_Genus) <- c()
Genus_SM <- data.frame(Only_SM_Genus[which(apply(Only_SM_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)


Genus_SM2 <- column_to_rownames(Genus_SM, "Taxonomic_ID")

Only_SM_Genus_czm <- cmultRepl(t(Genus_SM),  label=0, method="CZM")

Only_SM_Genus_clr <- t(apply(Only_SM_Genus_czm, 1, function(x){log(x) - mean(log(x))}))

Only_SM_Genus_pcx <- prcomp(Only_SM_Genus_clr)

Only_SM_Genus_mvar <- sum(Only_SM_Genus_pcx$sdev^2)
# Calculate the PC1 and PC2 variance

PC1_no <- paste("PC1: ", round(sum(Only_SM_Genus_pcx$sdev[1]^2)/Only_SM_Genus_mvar, 3))
PC2_no <- paste("PC2: ", round(sum(Only_SM_Genus_pcx$sdev[2]^2)/Only_SM_Genus_mvar, 3))

col.g=c("black",rgb(1,0,0,0.4))
size.g=c(0.5, 0.4)

png("Biplot_Only_SM_Genus.png", width = 5, height = 5, units = "in", res = 300)
biplot(Only_SM_Genus_pcx, cex=size.g, col=col.g, var.axes=F,
    xlab=paste("PC1: ", round(sum(Only_SM_Genus_pcx$sdev[1]^2)/Only_SM_Genus_mvar, 3)),
    ylab=paste("PC2: ", round(sum(Only_SM_Genus_pcx$sdev[2]^2)/Only_SM_Genus_mvar, 3)),
    scale=0, 
)
abline(h=0, lty=2, col=rgb(0,0,0,0.1))
abline(v=0, lty=2, col=rgb(0,0,0,0.1))
dev.off()

png("Only_SM_Genus_clustering.png", width = 5, height = 5, units = "in", res = 300)
hc_Only_SM_Genus <- hclust(dist(Only_SM_Genus_clr))
plot(hc_Only_SM_Genus, hang=-1)
dev.off()

```



```{r}
conds <- c("DirectSM","DirectSM","DirectSM","SM","SM","SM")

x_distr <- aldex.clr(Genus_no_Hive7_all_2, conds, mc.samples=128, verbose=TRUE)
```

trial

```{r}
conds2 <- c("DirectSM","DirectSM","DirectSM","DirectSM","SM","SM","SM","SM")

trial_samples <- column_to_rownames(Hives_comparison_species, "Taxonomic_ID")

trial_samples_df <- data.frame(trial_samples[which(apply(trial_samples, 1, function(x){mean(x)}) > 1),], check.names=F)

x_distr_try <- aldex.clr(trial_samples_df, conds2, mc.samples=128, verbose=TRUE)

distr_valus <- getMonteCarloInstances(x_distr_try)


sample_trial <- read.csv("C:/Users/user/Desktop/data_frames/simulations/sample.csv")
conds3 <- c("Sample1","Sample1","Sample2","Sample2")
x_distr_try2 <- aldex.clr(sample_trial, conds3, mc.samples=128, verbose=TRUE)
distr_valus1 <- getDenom(x_distr_try2)

sample_czm <- codaSeq.clr(sample_trial)


```


```{r}

x.tt <- aldex.ttest(x_distr, conds, paired.test=FALSE)
x.effect <- aldex.effect(x_distr, conds, verbose=TRUE)
x.all <- data.frame(x.tt, x.effect, stringsAsFactors=FALSE)

png("Genus_no_Hive7_MA.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all, type="MA", test="welch")
dev.off()

png("Genus_no_Hive7_MW.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all, type="MW", test="welch")
dev.off()



conds2 <- c("DirectSM","DirectSM","DirectSM","DirectSM","SM","SM","SM","SM")

x_distr2 <- aldex.clr(Genus, conds2, mc.samples=128, verbose=TRUE)
x.tt2 <- aldex.ttest(x_distr2, conds2, paired.test=FALSE)
x.effect2 <- aldex.effect(x_distr2, conds2, verbose=TRUE)
x.all2 <- data.frame(x.tt2, x.effect2, stringsAsFactors=FALSE)

png("Genus_all_MA.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all2, type="MA", test="welch")
dev.off()

png("Genus_all_MW.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all2, type="MW", test="welch")
dev.off()

# Genus DSM

conds_dsm <- c("Hive_4","Hive_5","Hive_6","Hive_7")

x_distr_dsm <- aldex.clr(Genus_DSM, conds_dsm, mc.samples=20, verbose=TRUE)
x.tt_dsm <- aldex.kw(x_distr_dsm)
x.effect_dsm <- aldex.effect(x_distr_dsm, conds_dsm, verbose=TRUE)
x.all_dsm <- data.frame(x.tt_dsm, x.effect_dsm, stringsAsFactors=FALSE)

png("Genus_all_MA.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all2, type="MA", test="welch")
dev.off()

png("Genus_all_MW.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all2, type="MW", test="welch")
dev.off()



# Compare each Hive separately

Hive_4 <- Hives_comparison_genus %>% dplyr::select(.,c("Taxonomic_ID","DirectSM_H4","SM_H4"))
Hive_5 <- Hives_comparison_genus %>% dplyr::select(.,c("Taxonomic_ID","DirectSM_H5","SM_H5"))
Hive_6 <- Hives_comparison_genus %>% dplyr::select(.,c("Taxonomic_ID","DirectSM_H6","SM_H6"))
Hive_7 <- Hives_comparison_genus %>% dplyr::select(.,c("Taxonomic_ID","DirectSM_H7","SM_H7"))

DSM_7 <- Hives_comparison_genus %>% dplyr::select(.,"DirectSM_H7")
SM_7 <- Hives_comparison_genus %>% dplyr::select(.,"SM_H7")

wilcox.test(x_distr4@analysisData[["DirectSM_H4"]],x_distr4@analysisData[["SM_H4"]], paired = TRUE, var.equal = FALSE)
t.test(Hive_4_Genus$DirectSM_H4,Hive_4_Genus$SM_H4, paired = TRUE)
t.test(Hive_5_Genus$DirectSM_H5,Hive_5_Genus$SM_H5, paired = TRUE)

density1 <- density(Hive_4$DirectSM_H4)
plot(density1)


hist(Hives_comparison_genus$DirectSM_H5, prob=TRUE, breaks = 1)

fit <- fitdist(Hives_comparison_genus$DirectSM_H5, "nbinom")

fitD <- dnbinom(size=25.05688, mu=31.56127)






```

```{r}


new_genus1 <- as.data.frame(t(Genus_clr))
Hive_new <- new_genus1 %>% dplyr::select(.,c("DirectSM_H7","SM_H7"))
wilcox.test(Hive_new$DirectSM_H7,Hive_new$SM_H7,paired = TRUE, alternative = "greater")















Hive_4_Genus <- column_to_rownames(Hive_4, "Taxonomic_ID")
Hive_4_an <- data.frame(Hive_4_Genus[which(apply(Hive_4_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_5_Genus <- column_to_rownames(Hive_5, "Taxonomic_ID")
Hive_5_an <- data.frame(Hive_5_Genus[which(apply(Hive_5_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_6_Genus <- column_to_rownames(Hive_6, "Taxonomic_ID")
Hive_6_an <- data.frame(Hive_6_Genus[which(apply(Hive_6_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

Hive_7_Genus <- column_to_rownames(Hive_7, "Taxonomic_ID")
Hive_7_an <- data.frame(Hive_7_Genus[which(apply(Hive_7_Genus, 1, function(x){mean(x)}) > 1),], check.names=F)

conditions <- c("Direct_SM","SM")

x_distr4 <- aldex.clr(Hive_4_an, conditions, mc.samples=128, verbose=TRUE)
x.tt4 <- aldex.ttest(x_distr4, conditions, paired.test=TRUE)
x.effect4 <- aldex.effect(x_distr4, conditions, verbose=TRUE)
x.all4 <- data.frame(x.tt4, x.effect4, stringsAsFactors=FALSE)

png("Genus_all_MA.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all4, type="MA", test="welch")
dev.off()

png("Genus_all_MW.png", width = 5, height = 5, units = "in", res = 300)
aldex.plot(x.all4, type="MW", test="welch")
dev.off()



sig.op <- rownames(x.all4)[which(x.all4$we.eBH < 0.05 & x.all4$effect > 1)]

# What are the taxa that are significantly different?
# Using the OTU names, we can get the taxonomy from our taxon table
taxon[sig.op,]

# We can also look at the ALDEx output for the significant OTUs
x.all[sig.op,]


colours <- c("indianred1", "steelblue3",  "skyblue1", "mediumorchid","royalblue4", "olivedrab3",
   "pink", "#FFED6F", "mediumorchid3", "ivory2", "tan1", "aquamarine3", "#C0C0C0",
    "mediumvioletred", "#999933", "#666699", "#CC9933", "#006666", "#3399FF",
   "#993300", "#CCCC99", "#666666", "#FFCC66", "#6699CC", "#663366", "#9999CC", "#CCCCCC",
   "#669999", "#CCCC66", "#CC6600", "#9999FF", "#0066CC", "#99CCCC", "#999999", "#FFCC00",
   "#009999", "#FF9900", "#999966", "#66CCCC", "#339966", "#CCCC33", "#EDEDED"
)


x_no_2 <- aldex.clr(d.5_no, mc.samples=128, verbose=TRUE)
































propr.clo <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop("negative values found")
    if(any(is.na(X))) stop("NA values found")
  }
  return(sweep(X, 1, rowSums(X), "/"))
}

propr.clr <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop("negative values found")
    if(any(is.na(X))) stop("NA values found")
  }
  logX <- log(X)
  return(sweep(logX, 1, rowMeans(logX), "-"))
}

propr.vlr <- function(X, check=FALSE){
  if(check){
    if(any(X < 0))    stop("negative values found")
    if(any(is.na(X))) stop("NA values found")
  }
  logX <- log(X)
  Cov    <- stats::var(logX)  ## Note the avoidance of compositions::var
  D      <- ncol(logX)
  VarCol <- matrix(rep(diag(Cov), D), ncol = D)
  return(-2 * Cov + VarCol + t(VarCol))
}

propr.phisym <- function (X)
{
  Cov    <- stats::var(X)
  tmp    <- 2 * Cov / outer(diag(Cov), diag(Cov), "+")
  return((1-tmp)/(1+tmp))
}

propr.aldex.phi <- function(aldex.clr, return="df"){

	# calculate expected value of phi
	# a single high phi value will push the component out of consideration
	# a median is right out for memory considerations

	# get first value
	sym.phi <- propr.phisym(t(sapply(getMonteCarloInstances(aldex.clr),
	    function(y){y[,1]})))

	# sum the rest of the values as we proceed through the DIR MC instances
	for(i in 2:numMCInstances(aldex.clr)){
		#print(i)
		sym.phi <- sym.phi + propr.phisym(t(sapply(getMonteCarloInstances(aldex.clr),
		    function(y){y[,i]})))
	}
	##### Done ALDEx2 stuff

	# make indices of the correct size
	lt <- which(col(sym.phi)<row(sym.phi), arr.ind=FALSE)
	lt.ind <- which(col(sym.phi)<row(sym.phi), arr.ind=TRUE)

	# dataframe to hold the info,
	# data is a set of vectors where only the lower triangle is kept, because the matrix
	#    is symmetrical
	# this is needed so subsequent subset function works properly
	sma.df <- data.frame(row=factor(rownames(sym.phi)[lt.ind[,"row"]]),
		col=factor(colnames(sym.phi)[lt.ind[,"col"]]))

	#save the lower triangle as an expected value
	sma.df$phi <- sym.phi[lt] /  numMCInstances(aldex.clr)

	if(return=="df") return(sma.df)
	if(return=="mat") return(sym.phi /  numMCInstances(aldex.clr))
}

d.sma.df <- propr.aldex.phi(x_no_2)

phi.cutoff <- 0.25

# get the subset of OTUs that are joined by one or more low phi connections
d.sma.lo.phi <- subset(d.sma.df, phi < phi.cutoff)

g <- graph.data.frame(d.sma.lo.phi, directed=FALSE)

# igraph: find the clusters
g.clust <- clusters(g)

# make a table to examine the cluster membership by hand
g.df <- data.frame(Systematic.name=V(g)$name, cluster=g.clust$membership, 
    cluster.size=g.clust$csize[g.clust$membership])

# generate a set of clusters larger than some size # minimum is 2 (obviously)
big <- g.df[which(g.df$cluster.size >= 2),] 
colnames(big) <- colnames(g.df)

# igraph: rename the cluster members by their genus name
# gsub(pattern, replacement, strings, perl-syntax)
V(g)$name <- gsub("(^[A-Za-z]{3}).+", "\\1", as.vector(taxon[names(V(g)),"genus"]), 
    perl=TRUE)

# igraph:
# vertex.size controls point and text color
# vertex.color controls point color
# vertex.frame controls point outline color
png("network.png")
plot(g, vertex.size=2, vertex.color=rgb(0,0,0,0.2), vertex.frame.color="white")
dev.off()

```
```{r}
# DESEeq2 plots
hives_metadata <- read.csv("C:/Users/user/Desktop/data_frames/comparison/metadata_hives.csv")

Hives_dds <- DESeqDataSetFromMatrix(countData = Hives_comparison_genus, colData = hives_metadata, design = ~Method + Hive, tidy = TRUE)

Hives_dds_norm <- estimateSizeFactors(Hives_dds,type = "ratio")

dds.disp <- estimateDispersions(Hives_dds_norm)

png("dispersion.png")
plotDispEsts(dds.disp)
dev.off()

hives_no_Hive7_metadata <- read.csv("C:/Users/user/Desktop/data_frames/comparison/No_Hive7/metadata_hives_no_Hive7.csv")

Hives_dds_no <- DESeqDataSetFromMatrix(countData = Hives_comparison_no_Hive7_genus, colData = hives_no_Hive7_metadata, design = ~Method + Hive, tidy = TRUE)

Hives_dds_norm_no <- estimateSizeFactors(Hives_dds,type = "ratio")

dds.disp_no <- estimateDispersions(Hives_dds_norm_no)

png("dispersion_no_Hive7.png")
plotDispEsts(dds.disp_no)
dev.off()


```


```{r}
get_pca <- function(res.pca, element = c("var", "ind")){
  elmt <- match.arg(element)
  if(elmt =="var") get_pca_var(res.pca)
  else if(elmt == "ind") get_pca_ind(res.pca)
}

#' @rdname get_pca
#' @export
get_pca_ind<-function(res.pca, ...){
  
  # FactoMineR package
  if(inherits(res.pca, c('PCA'))) ind <- res.pca$ind
  
  # ade4 package
  else if(inherits(res.pca, 'pca') & inherits(res.pca, 'dudi')){  
    ind.coord <- res.pca$li
    # get the original data
    data <- res.pca$tab
    data <- t(apply(data, 1, function(x){x*res.pca$norm} ))
    data <- t(apply(data, 1, function(x){x+res.pca$cent}))
    ind <- .get_pca_ind_results(ind.coord, data, res.pca$eig,
                                res.pca$cent, res.pca$norm)
  }
  
  # stats package
  else if(inherits(res.pca, 'princomp')){  
    ind.coord <- res.pca$scores
    data <- .prcomp_reconst(res.pca)
    ind <- .get_pca_ind_results(ind.coord, data, res.pca$sdev^2,
                                res.pca$center, res.pca$scale)
    
  }
  else if(inherits(res.pca, 'prcomp')){
    ind.coord <- res.pca$x
    data <- .prcomp_reconst(res.pca)
    ind <- .get_pca_ind_results(ind.coord, data, res.pca$sdev^2,
                                res.pca$center, res.pca$scale)
  }
  # ExPosition package
  else if (inherits(res.pca, "expoOutput") & inherits(res.pca$ExPosition.Data,'epPCA')){
    res <- res.pca$ExPosition.Data
    ind <- list(coord = res$fi,  cos2 = res$ri, contrib = res$ci*100)
  }
  else stop("An object of class : ", class(res.pca), 
            " can't be handled by the function get_pca_ind()")
  
  class(ind)<-c("factoextra", "pca_ind")
  
  ind
}


#' @rdname get_pca
#' @export 
get_pca_var<-function(res.pca){
  # FactoMineR package
  if(inherits(res.pca, c('PCA'))) var <- res.pca$var
  # ade4 package
  else if(inherits(res.pca, 'pca') & inherits(res.pca, 'dudi')){
    var <- .get_pca_var_results(res.pca$co)
  }
  # stats package
  else if(inherits(res.pca, 'princomp')){   
    # Correlation of variables with the principal component
    var_cor_func <- function(var.loadings, comp.sdev){var.loadings*comp.sdev}
    var.cor <- t(apply(res.pca$loadings, 1, var_cor_func, res.pca$sdev))
    var <- .get_pca_var_results(var.cor)
  }
  else if(inherits(res.pca, 'prcomp')){
    # Correlation of variables with the principal component
    var_cor_func <- function(var.loadings, comp.sdev){var.loadings*comp.sdev}
    var.cor <- t(apply(res.pca$rotation, 1, var_cor_func, res.pca$sdev))
    var <- .get_pca_var_results(var.cor)
  }
  # ExPosition package
  else if (inherits(res.pca, "expoOutput") & inherits(res.pca$ExPosition.Data,'epPCA')){
    res <- res.pca$ExPosition.Data
    data_matrix <- res$X
    factor_scores <- res$fi
    var.coord <- var.cor <- stats::cor(res$X, res$fi) # cor(t(data_matrix), factor_scores)
    var.coord <- replace(var.coord, is.na(var.coord), 0)
    var <- list(coord = var.coord, cor = var.coord, cos2 = res$rj, contrib = res$cj*100)
  }
  else stop("An object of class : ", class(res.pca), 
            " can't be handled by the function get_pca_var()")
  class(var)<-c("factoextra", "pca_var")
  var
}




# Helper functions
#++++++++++++++++++++

# compute all the results for individuals : coord, cor, cos2, contrib
# ind.coord : coordinates of variables on the principal component
# pca.center, pca.scale : numeric vectors corresponding to the pca
# center and scale respectively
# data : the orignal data used during the pca analysis
# eigenvalues : principal component eigenvalues
.get_pca_ind_results <- function(ind.coord, data, eigenvalues, pca.center, pca.scale ){
  
  eigenvalues <- eigenvalues[1:ncol(ind.coord)]
  
  if(pca.center[1] == FALSE) pca.center <- rep(0, ncol(data))
  if(pca.scale[1] == FALSE) pca.scale <- rep(1, ncol(data))
  
  # Compute the square of the distance between an individual and the
  # center of gravity
  getdistance <- function(ind_row, center, scale){
    return(sum(((ind_row-center)/scale)^2))
  }
  d2 <- apply(data, 1,getdistance, pca.center, pca.scale)
  
  # Compute the cos2
  cos2 <- function(ind.coord, d2){return(ind.coord^2/d2)}
  ind.cos2 <- apply(ind.coord, 2, cos2, d2)
  
  # Individual contributions 
  contrib <- function(ind.coord, eigenvalues, n.ind){
    100*(1/n.ind)*(ind.coord^2/eigenvalues)
  }
  ind.contrib <- t(apply(ind.coord, 1, contrib,  eigenvalues, nrow(ind.coord)))
  
  colnames(ind.coord) <- colnames(ind.cos2) <-
    colnames(ind.contrib) <- paste0("Dim.", 1:ncol(ind.coord)) 
  
  rnames <- rownames(ind.coord)
  if(is.null(rnames)) rnames <- as.character(1:nrow(ind.coord))
  rownames(ind.coord) <- rownames(ind.cos2) <- rownames(ind.contrib) <- rnames
  
  # Individuals coord, cos2 and contrib
  ind = list(coord = ind.coord,  cos2 = ind.cos2, contrib = ind.contrib)
  ind
}

# compute all the results for variables : coord, cor, cos2, contrib
# var.coord : coordinates of variables on the principal component
.get_pca_var_results <- function(var.coord){
  
  var.cor <- var.coord # correlation
  var.cos2 <- var.cor^2 # variable qualities 
  
  # variable contributions (in percent)
  # var.cos2*100/total Cos2 of the component
  comp.cos2 <- apply(var.cos2, 2, sum)
  contrib <- function(var.cos2, comp.cos2){var.cos2*100/comp.cos2}
  var.contrib <- t(apply(var.cos2,1, contrib, comp.cos2))
  
  colnames(var.coord) <- colnames(var.cor) <- colnames(var.cos2) <-
    colnames(var.contrib) <- paste0("Dim.", 1:ncol(var.coord)) 
  
  # Variable coord, cor, cos2 and contrib
  list(coord = var.coord, cor = var.cor, cos2 = var.cos2, contrib = var.contrib)
}



fviz_pca_biplot <- function(X,  axes = c(1,2), geom = c("point", "text"),
                            geom.ind = geom, geom.var = c("arrow", "text"),
                            col.ind = "black", fill.ind = "white", 
                            col.var = "steelblue", fill.var = "white", gradient.cols = NULL,
                            label = "all", invisible="none", repel = FALSE, 
                            habillage = "none", palette = NULL, addEllipses=FALSE, 
                            title = "PCA - Biplot", ...)
{
  
  # Check if individials or variables are colored by variables
  is.individuals.colored.by.variable <- .is_grouping_var(fill.ind) | .is_grouping_var(col.ind)
  is.variables.colored.by.variable <-  .is_continuous_var(col.var) | .is_grouping_var(col.var)
  # If coloring variable are continuous, then gradient coloring shoulld be applied
  is.gradient.color <- .is_continuous_var(col.ind) | .is_continuous_var(col.var) 
  is.gradient.fill <- .is_continuous_var(fill.ind) | .is_continuous_var(fill.var)
  # If coloring variables are qualitative, then discrete coloring should be applied
  is.discrete.color <- .is_grouping_var(col.ind) | .is_grouping_var(habillage) | .is_grouping_var(col.var)
  is.discrete.fill <- .is_grouping_var(fill.ind) | .is_grouping_var(fill.var) |
                       .is_grouping_var(habillage) | (.is_grouping_var(col.ind) & addEllipses)
  
  
  # Data frame to be used for plotting
  var <- facto_summarize(X, element = "var", 
                         result = c("coord", "contrib", "cos2"), axes = axes)
  colnames(var)[2:3] <-  c("x", "y")
  
  pca.ind <- get_pca_ind(X)
  ind <- data.frame(pca.ind$coord[, axes, drop=FALSE], stringsAsFactors = TRUE)
  colnames(ind)<- c("x", "y")
  
  # rescale variable coordinates
  r <- min(
    (max(ind[,"x"])-min(ind[,"x"])/(max(var[,"x"])-min(var[,"x"]))),
    (max(ind[,"y"])-min(ind[,"y"])/(max(var[,"y"])-min(var[,"y"])))
  )
  
  # When fill.ind = grouping variable & col.var = continuous variable,
  # we should inactivate ellipse border and ind.point border colors,
  # otherwise --> error: Discrete value supplied to continuous scale
  # Reason: individuals are in discrete color and variable in gradient colors, 
  # and we can't change the color (https://github.com/kassambara/factoextra/issues/42)
  ellipse.border.remove  <- FALSE
  if(is.individuals.colored.by.variable & is.variables.colored.by.variable)
    ellipse.border.remove <- TRUE

  
  
  # Individuals
  p <- fviz_pca_ind(X,  axes = axes, geom = geom.ind, repel = repel,
                    col.ind = col.ind, fill.ind = fill.ind,
                    label = label, invisible=invisible, habillage = habillage,
                    addEllipses = addEllipses, # palette = palette, 
                    ellipse.border.remove = ellipse.border.remove,
                    ...)
  # Add variables
  p <- fviz_pca_var(X, axes = axes, geom =  geom.var, repel = repel,
                    col.var = col.var, fill.var = fill.var,
                    label = label, invisible = invisible,
                    scale.= r*0.7, ggp = p,  ...)
  
  if(!is.null(gradient.cols)){
    if(is.gradient.color) p <- p + ggpubr::gradient_color(gradient.cols)
    if(is.gradient.fill) p <- p + ggpubr::gradient_fill(gradient.cols)
  }
  
  if(!is.null(palette)){
    if(is.discrete.color) p <- p + ggpubr::color_palette(palette)
    if(is.discrete.fill) p <- p + ggpubr::fill_palette(palette)
     
  }
  
  p+labs(title=title)
}


```


```{r}
#' @include utilities.R
NULL
#'Visualizing Multivariate Analyse Outputs
#'@description Generic function to create a scatter plot of multivariate analyse
#'  outputs, including PCA, CA, MCA and MFA.
#'@inheritParams facto_summarize
#'@param geom a text specifying the geometry to be used for the graph. Default 
#'  value is "auto". Allowed values are the combination of c("point", "arrow", 
#'  "text"). Use "point" (to show only points); "text" to show only labels; 
#'  c("point", "text") or c("arrow", "text") to show both types.
#'@param label a text specifying the elements to be labelled. Default value is 
#'  "all". Allowed values are "none" or the combination of c("ind", "ind.sup", 
#'  "quali", "var", "quanti.sup", "group.sup"). "ind" can be used to label only 
#'  active individuals. "ind.sup" is for supplementary individuals. "quali" is 
#'  for supplementary qualitative variables. "var" is for active variables. 
#'  "quanti.sup" is for quantitative supplementary variables.
#'@param invisible a text specifying the elements to be hidden on the plot. 
#'  Default value is "none". Allowed values are the combination of c("ind", 
#'  "ind.sup", "quali", "var", "quanti.sup", "group.sup").
#'@param labelsize font size for the labels
#'@param pointsize the size of points
#'@param pointshape the shape of points
#'@param arrowsize the size of arrows. Controls the thickness of arrows.
#'@param title the title of the graph
#'@param repel a boolean, whether to use ggrepel to avoid overplotting text 
#'  labels or not.
#'@param habillage an optional factor variable for coloring the observations by 
#'  groups. Default value is "none". If X is a PCA object from FactoMineR 
#'  package, habillage can also specify the supplementary qualitative variable 
#'  (by its index or name) to be used for coloring individuals by groups (see 
#'  ?PCA in FactoMineR).
#'@param addEllipses logical value. If TRUE, draws ellipses around the 
#'  individuals when habillage != "none".
#'@param ellipse.level the size of the concentration ellipse in normal 
#'  probability.
#'@param ellipse.type Character specifying frame type. Possible values are 
#'  \code{"convex"}, \code{"confidence"} or types supported by 
#'  \code{\link[ggplot2]{stat_ellipse}()} including one of \code{c("t", "norm", 
#'  "euclid")} for plotting concentration ellipses.
#'  
#'  \itemize{ \item \code{"convex"}: plot convex hull of a set o points. \item 
#'  \code{"confidence"}: plot confidence ellipses arround group mean points as
#'  \code{\link[FactoMineR]{coord.ellipse}()}[in FactoMineR]. \item \code{"t"}:
#'  assumes a multivariate t-distribution. \item \code{"norm"}: assumes a
#'  multivariate normal distribution. \item \code{"euclid"}: draws a circle with
#'  the radius equal to level, representing the euclidean distance from the
#'  center. This ellipse probably won't appear circular unless
#'  \code{\link[ggplot2]{coord_fixed}()} is applied.}
#'  
#'  
#'@param ellipse.alpha Alpha for ellipse specifying the transparency level of 
#'  fill color. Use alpha = 0 for no fill color.
#'@param mean.point logical value. If TRUE (default), group mean points are 
#'  added to the plot.
#'@param col.circle a color for the correlation circle. Used only when X is a 
#'  PCA output.
#'@param circlesize the size of the variable correlation circle.
#'@param axes.linetype linetype of x and y axes.
#'@param color color to be used for the specified geometries (point, text). Can 
#'  be a continuous variable or a factor variable. Possible values include also 
#'  : "cos2", "contrib", "coord", "x" or "y". In this case, the colors for 
#'  individuals/variables are automatically controlled by their qualities of 
#'  representation ("cos2"), contributions ("contrib"), coordinates (x^2+y^2, 
#'  "coord"), x values ("x") or y values ("y"). To use automatic coloring (by 
#'  cos2, contrib, ....), make sure that habillage ="none".
#'@param fill same as the argument \code{color}, but for point fill color. 
#'  Useful when pointshape = 21, for example.
#'@param alpha controls the transparency of individual and variable colors, 
#'  respectively. The value can variate from 0 (total transparency) to 1 (no 
#'  transparency). Default value is 1. Possible values include also : "cos2", 
#'  "contrib", "coord", "x" or "y". In this case, the transparency for the 
#'  individual/variable colors are automatically controlled by their qualities 
#'  ("cos2"), contributions ("contrib"), coordinates (x^2+y^2, "coord"), x 
#'  values("x") or y values("y"). To use this, make sure that habillage ="none".
#'@param col.col.sup,col.row.sup colors for the supplementary column and row 
#'  points, respectively.
#'@param select a selection of individuals/variables to be drawn. Allowed values
#'  are NULL or a list containing the arguments name, cos2 or contrib: \itemize{
#'  \item name: is a character vector containing individuals/variables to be 
#'  drawn \item cos2: if cos2 is in [0, 1], ex: 0.6, then individuals/variables 
#'  with a cos2 > 0.6 are drawn. if cos2 > 1, ex: 5, then the top 5 
#'  individuals/variables with the highest cos2 are drawn. \item contrib: if 
#'  contrib > 1, ex: 5,  then the top 5 individuals/variables with the highest 
#'  contrib are drawn }
#'@param ggp a ggplot. If not NULL, points are added to an existing plot.
#'@inheritParams ggpubr::ggpar
#'@param font.family character vector specifying font family.
#'@param ... Arguments to be passed to the functions ggpubr::ggscatter() & 
#'  ggpubr::ggpar().
#'  
#'@return a ggplot
#'@author Alboukadel Kassambara \email{alboukadel.kassambara@@gmail.com}
#'  
#'@rdname fviz
#' @examples
#' \donttest{
#' # Principal component analysis
#' # +++++++++++++++++++++++++++++
#' data(decathlon2)
#' decathlon2.active <- decathlon2[1:23, 1:10]
#' res.pca <- prcomp(decathlon2.active,  scale = TRUE)
#' fviz(res.pca, "ind") # Individuals plot
#' fviz(res.pca, "var") # Variables plot
#' 
#' # Correspondence Analysis
#' # ++++++++++++++++++++++++++
#' # Install and load FactoMineR to compute CA
#' # install.packages("FactoMineR")
#' library("FactoMineR")
#' data("housetasks")
#' res.ca <- CA(housetasks, graph = FALSE)
#' fviz(res.ca, "row") # Rows plot
#' fviz(res.ca, "col") # Columns plot
#' 
#' # Multiple Correspondence Analysis
#' # +++++++++++++++++++++++++++++++++
#' library(FactoMineR)
#' data(poison)
#' res.mca <- MCA(poison, quanti.sup = 1:2, 
#'               quali.sup = 3:4, graph=FALSE)
#'               
#' fviz(res.mca, "ind") # Individuals plot
#' fviz(res.mca, "var") # Variables plot
#' 
#'  }
#'@export
fviz <- function(X, element, axes = c(1, 2), geom = "auto",
                          label = "all", invisible="none", labelsize=4, 
                          pointsize = 1.5, pointshape = 19, arrowsize = 0.5,
                          habillage="none", addEllipses=FALSE, ellipse.level = 0.95, 
                          ellipse.type = "norm", ellipse.alpha = 0.1, mean.point = TRUE,
                          color = "black", fill = "white", alpha = 1, gradient.cols = NULL,
                          col.row.sup = "darkblue", col.col.sup="darkred",
                          select = list(name = NULL, cos2 = NULL, contrib = NULL),
                          title = NULL, axes.linetype = "dashed",
                          repel = FALSE, col.circle ="grey70", circlesize = 0.5, ggtheme = theme_minimal(),
                          ggp = NULL, font.family = "",
                           ...)
  {
  
  .check_axes(axes, .length = 2)
  facto.class <- .get_facto_class(X)
    
  # Deprecated arguments: jitter
  extra_args <- list(...)
  if(!is.null(extra_args$jitter)) repel <- .facto_dep("jitter", "repel", TRUE)
  # Elements to be labelled or hidden
  lab <- .label(label)
  hide <- .hide(invisible)
  
  # Define parameters
  #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  # Define title if NULL
  if(is.null(title)){
    element_desc <- list(ind = "Individuals", var = "Variables",
                         col = "Column points", row = "Row points",
                         mca.cor = "Variables", quanti.sup = "Quantitative variables",
                         quanti.var = "Quantitative variables",
                         quali.var = "Qualitative variable categories",
                         group = "Variable groups", partial.axes = "Partial axes")
    if(facto.class == "MCA") element_desc$var <- "Variable categories"
    title <- paste0(element_desc[[element]], " - ", facto.class)
  }
  # Define geometry if auto
  if(geom[1] == "auto"){
    geom <- c("point", "text")
    if(element == "var" & facto.class == "PCA") geom <- c("arrow", "text")
  }
  # Define color if missing
  if(facto.class %in% c("CA", "MCA")){
    if(element %in% c("row", "ind") & missing(color)) color = "blue"
    else if(element %in% c("col", "var", "mca.cor") & missing(color)) color = "red"
  }

  # Data preparation
  #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  # Data frame to be used for plotting
  summary.res <- c("coord", "contrib", "cos2")
  if(element == "partial.axes" | (element == "quali.var" & facto.class == "HMFA")) 
    summary.res <- c("coord", "contrib")
  else if(element == "group" & facto.class == "HMFA") summary.res <- "coord"
  df <- facto_summarize(X, element = element, axes = axes, result = summary.res)
  colnames(df)[2:3] <-  c("x", "y")
  # Color by grouping variables
  #::::::::::::::::::::::::::::::::::::::
  is_grouping_var_exists <- !("none" %in% habillage) | .is_grouping_var(color) | .is_grouping_var(fill)
  # Augment data, if qualitative variable is used to color points by groups
  if(!("none" %in% habillage)){
    dd <- .add_ind_groups(X, df, habillage)
    df <- dd$ind
    color <- dd$name.quali
    if(missing(pointshape)) pointshape <- dd$name.quali
  }
  # Augment data if color is a continuous variable or a factor variable
  if(length(color) > 1){
    if(nrow(df) != length(color)) stop("The length of color variable",
                                    "should be the same as the number of rows in the data.")
    .col.name <- "Col."
    df[[.col.name]] <- color
    if(missing(pointshape) & .is_grouping_var(color)) pointshape <- .col.name
    color <- .col.name
  }
  # Augment data if fill is a continuous variable or a factor variable
  if(length(fill) > 1){
    if(nrow(df) != length(fill)) stop("The length of fill variable",
                                       "should be the same as the number of rows in the data.")
    .col.name <- "Fill."
    df[[.col.name]] <- fill
    fill <- .col.name
  }
  # Augment the data, if pointsize is a continuous variable
  if(length(pointsize) > 1){
    if(nrow(df) != length(pointsize)) pointsize <- 1.5
    df[["pointsize"]] <- pointsize
    pointsize <- "pointsize"
  }
  # Selection
  df.all <- df
  if(!is.null(select)) df <- .select(df, select)
  
  # Special cases: data transformation
  #%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  # Used by fviz_pca_biplot() only:  Multiply the variables data by scale. before biplotting
  if(facto.class == "PCA" & element == "var" & !is.null(extra_args$scale.) )
    df[, c("x", "y")] <- df[, c("x", "y")]*extra_args$scale.
  # (M)CA: scale coords according to the type of map
  if(facto.class %in% c("CA", "MCA") & !(element %in% c("mca.cor", "quanti.sup"))){
  if(!is.null(extra_args$map)) df <- .scale_ca(df, res.ca = X,  element = element, 
                                               type = extra_args$map, axes = axes)
  }
  # Main plot
  #%%%%%%%%%%%%%%%%%%%
  is.pca.var <- element == "var" & facto.class == "PCA" # We don't want meanpoint for PCA variables colored by groups
  point <- ("point" %in% geom) & (!hide[[element]]) # to show points, should be TRUE
  if(missing(mean.point))
    mean.point <- (is_grouping_var_exists & !is.pca.var) & ("point" %in% geom) & (!hide[["quali"]]) # to show mean point
  if(element == "quanti.var") mean.point <- FALSE # MFA, don't show the mean point of groups of variables
  
  label <- NULL
  if(lab[[element]] & "text" %in% geom & !hide[[element]]) label <- "name"
  
  p <- ggplot() 
  if(hide[[element]]) {
    if(is.null(ggp)) p <-ggplot()+geom_blank(data = df, aes_string("x","y"))
    else p <- ggp
  }
  else p <- ggpubr::ggscatter(data = df, x = "x", y = "y",
                         color = color, fill = fill,  alpha = alpha, shape = pointshape, 
                         point = point, size = pointsize, mean.point = mean.point,
                         label = label, font.label = labelsize*3, repel = repel,
                         ellipse = addEllipses, ellipse.type = ellipse.type,
                         ellipse.alpha = ellipse.alpha, ellipse.level = ellipse.level,
                         main = title, ggtheme = ggtheme, ggp = ggp, font.family = font.family, ...)
  if(alpha %in% c("cos2","contrib", "coord", "x", "y"))
    p <- p + scale_alpha(limits = range(df.all[, alpha]))
  
  if(!is.null(gradient.cols))
    p <- p + ggpubr::gradient_color(gradient.cols)
    
    
  if(is.null(extra_args$legend)) p <- p + theme(legend.position = "right" )
  # Add arrows
  if("arrow" %in% geom & !hide[[element]]) 
    p <- p + .arrows(data = df, color = color, alpha = alpha, size = arrowsize)
  # Add correlation circle if PCA & element = "var" & scale = TRUE
  if(facto.class == "PCA" & element == "var"){
    if(.get_scale_unit(X) & is.null(extra_args$scale.)) 
      p <- .add_corr_circle(p, color = col.circle, size = circlesize)
  }
  else if(facto.class %in% c("MCA", "MFA", "HMFA", "FAMD") & element %in% c("quanti.sup", "quanti.var", "partial.axes")){
      p <- .add_corr_circle(p, color = col.circle, size = circlesize)
  }
  # Faceting when multiple variables are used to color individuals
  # (e.g., habillage = 1:2, or data.frame)
  # in this case there is a column "facet_vars" in df
  if("facet_vars" %in% colnames(df)){
    groups <- c("facet_vars", "Groups")
    xx <- ggpubr::desc_statby(df, measure.var = "x", grps = groups)[, c(groups, "mean")]
    colnames(xx)[ncol(xx)] <- "x"
    yy <- ggpubr::desc_statby(df, measure.var = "y", grps = groups)[, c(groups, "mean")]
    xx$y <- yy$mean
    grp_coord <- xx
   
    p <- p+ggpubr::geom_exec(geom_text, data = grp_coord, x = "x", y = "y",
                             label = "Groups", color = color) 
    p <- p + facet_wrap(~facet_vars) + theme(legend.position = "none") 
  }
  
  # Supplementary elements: available only for FactoMineR
  #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  scale. <- ifelse(is.null(extra_args$scale.), 1, extra_args$scale.)
  esup <- .define_element_sup(X, element, geom = geom, lab = lab, hide = hide,
                              col.row.sup = col.row.sup, col.col.sup = col.col.sup,...) 
  ca_map = extra_args$map
  if(element == "mca.cor") ca_map = NULL
  
  if(!is.null(esup)) p <- .add_supp (p, X, element = esup$name, axes = axes, select = select,
                                geom = geom, color = esup$color, shape = esup$shape, pointsize = pointsize,
                                labelsize = labelsize, addlabel = esup$addlabel, repel = repel, linetype = 2,
                                scale. = scale., ca_map = ca_map, font.family = font.family)
  
  
  p <- .fviz_finish(p, X, axes, axes.linetype, ...) +
    labs(title = title) 
  
  p
}


#+++++++++++++++++++++
# Helper functions
#+++++++++++++++++++++


# Check if fill/color variable is continous in the context of PCA
.is_continuous_var <- function(x){
  x[1] %in% c("cos2", "contrib", "x", "y") | is.numeric(x)
}

.is_grouping_var <- function(x){
  length(x) > 1 & (is.character(x) | is.factor(x))
}
# Check if is continuous or grouping variable in the context of PCA
.is_variable <- function(x){
  .is_continuous_var(x) | .is_grouping_var(x)
}


# Check if character string is a valid color representation
.is_color <- function(x) {
  sapply(x, function(X) {
    tryCatch(is.matrix(grDevices::col2rgb(X)),
             error = function(e) FALSE)
  })
}


# X : an object of class PCA, princomp, prcomp, dudi, expoOutput
# Return TRUE if the data are scaled to unit variance
.get_scale_unit <-function(X){
  scale_unit <- FALSE
  if(inherits(X, 'PCA')) scale_unit <- X$call$scale.unit
  else if(inherits(X, "prcomp" )) scale_unit <- is.numeric(X$scale) 
  else if(inherits(X, "princomp")) scale_unit <- length(unique(X$scale))>1 
  else if(inherits(X, "expoOutput")) scale_unit <- !all(X$ExPosition.Data$scale==1) 
  else if(inherits(X, 'pca') & inherits(X, 'dudi')) scale_unit <- length(unique(X$norm))>1 
  else {
    warning(".get_scale_unit function: can't handle an object of class ",
            class(X))
  }
  scale_unit
}

# Add correlation circle to variables plot
.add_corr_circle <- function(p, color = "grey70", size = 0.5){
  theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
  circle <- data.frame(xcircle = cos(theta), ycircle = sin(theta), stringsAsFactors = TRUE)
  p + 
    geom_path(mapping = aes_string("xcircle", "ycircle"), data = circle, color = color,
              size = size) +
    coord_fixed()
  
}

# Add arrow to the plot
.arrows <- function(data, color = "black", alpha = 1, size =0.5,
                    origin = 0, xend = "x", yend = "y"){
  origin <- rep(origin, nrow(data))
  dd <- cbind.data.frame(data, xstart = origin, ystart = origin, stringsAsFactors = TRUE)
  ggpubr::geom_exec(geom_segment, data = dd, 
                    x = "xstart", y = "ystart", xend = xend, yend = yend,
                    arrow = grid::arrow(length = grid::unit(0.2, 'cm')),
                    color = color, alpha = alpha, size = size)
}



# Define element sup if any
# lab,hide: element to be labelled or hidden as returned by .hide() and .label()
.define_element_sup <- function(X, element, geom, lab, hide,
                                col.row.sup = "darkblue", col.col.sup = "darkred", 
                                 ...){
  
  extra_args <- list(...)
  shape.sup <- ifelse(is.null(extra_args$shape.sup), 19, extra_args$shape.sup)
  color <- col.row.sup
  if(element %in% c("var", "mca.cor", "col", "group", "quanti.var")) color <- col.col.sup
    
  res <- NULL
  # Supplementary individuals
  if(element == "ind" & inherits(X, c('PCA', "MCA", "MFA", "FAMD")) & !hide$ind.sup)
    res <- list(name = "ind.sup", addlabel = (lab$ind.sup & "text" %in% geom))
  # Supplementary quantitative variables
  else if(element == "var" & inherits(X, 'PCA') & !hide$quanti.sup)
    res <- list(name = "quanti", addlabel = (lab$quanti.sup & "text" %in% geom))
  else if(element == "mca.cor" & inherits(X, 'MCA') & !hide$quanti)
    res <- list(name = c("quanti.sup", "quali.sup$eta2"), addlabel = (lab$quanti & "text" %in% geom))
  else if(element %in% "var" & inherits(X, 'MCA') & !hide$quali.sup)
    res <- list(name = "quali.sup", addlabel = (lab$quali.sup & "text" %in% geom))
  else if(element %in% "quali.var" & inherits(X, 'MFA') & !hide$quali.sup)
    res <- list(name = "quali.sup", addlabel = (lab$quali.sup & "text" %in% geom))
  else if(element %in% "var" & inherits(X, 'FAMD') & !hide$quanti.sup)
    res <- list(name = "quanti.sup", addlabel = (lab$quanti.sup & "text" %in% geom))
  # CA
  else if(element == "row" & inherits(X, c('CA', 'ca')) & !hide$row.sup)
    res <- list(name = "row.sup", addlabel = (lab$row.sup & "text" %in% geom))
  else if(element == "col" & inherits(X, c('CA', 'ca')) & !hide$row.sup)
    res <- list(name = "col.sup", addlabel = (lab$col.sup & "text" %in% geom))
  else if(element == "group" & inherits(X, c('MFA')) & !hide$group.sup)
    res <- list(name = "group", addlabel = (lab$group.sup & "text" %in% geom))
  else if(element == "quanti.var" & inherits(X, c('MFA')) & !hide$quanti.var.sup)
    res <- list(name = "quanti.var.sup", addlabel = (lab$quanti.var.sup & "text" %in% geom))
  
  res$color <- color
  res$shape <- shape.sup
  res
}

```
```{r}
#' @include utilities.R get_pca.R eigenvalue.R
NULL
#' Subset and summarize the output of factor analyses
#' 
#' @description Subset and summarize the results of Principal Component Analysis
#'   (PCA), Correspondence Analysis (CA), Multiple Correspondence Analysis
#'   (MCA), Factor Analysis of Mixed Data (FAMD), Multiple Factor Analysis
#'   (MFA) and Hierarchical Multiple Factor Analysis (HMFA) functions from several packages.
#' @param X an object of class PCA, CA, MCA, FAMD, MFA and HMFA [FactoMineR]; prcomp
#'   and princomp [stats]; dudi, pca, coa and acm [ade4]; ca [ca package]; expoOutput [ExPosition].
#' @param element the element to subset from the output. Possible values are 
#'   "row" or "col" for CA; "var" or "ind" for PCA and MCA; "mca.cor" for MCA; 
#'   'quanti.var', 'quali.var' , 'group' or 'ind' for FAMD, MFA and HMFA.
#' @param result the result to be extracted for the element. Possible values are
#'   the combination of c("cos2", "contrib", "coord")
#' @param group.names a vector containing the name of the groups (by default, 
#'   NULL and the group are named group.1, group.2 and so on).
#' @param node.level a single number indicating the HMFA node level.
#' @param axes a numeric vector specifying the axes of interest. Default values 
#'   are 1:2 for axes 1 and 2.
#' @param select a selection of variables. Allowed values are NULL or a list 
#'   containing the arguments name, cos2 or contrib. Default is list(name = 
#'   NULL, cos2 = NULL, contrib = NULL): \itemize{ \item name: is a character 
#'   vector containing variable names to be selected \item cos2: if cos2 is in 
#'   [0, 1], ex: 0.6, then variables with a cos2 > 0.6 are selected. if cos2 > 
#'   1, ex: 5, then the top 5 variables with the highest cos2 are selected \item
#'   contrib: if contrib > 1, ex: 5,  then the top 5 variables with the highest 
#'   cos2 are selected. }
#' @return A data frame containing the (total) coord, cos2 and the contribution 
#'   for the axes.
#' @details If length(axes) > 1, then the columns contrib and cos2 correspond to
#'   the total contributions and total cos2 of the axes. In this case, the 
#'   column coord is calculated as x^2 + y^2 + ...+; x, y, ... are the 
#'   coordinates of the points on the specified axes.
#' @author Alboukadel Kassambara \email{alboukadel.kassambara@@gmail.com}
#' @references http://www.sthda.com/english/
#' @examples
#' # Principal component analysis
#' # +++++++++++++++++++++++++++++
#' data(decathlon2)
#' decathlon2.active <- decathlon2[1:23, 1:10]
#' res.pca <- prcomp(decathlon2.active,  scale = TRUE)
#' 
#' # Summarize variables on axes 1:2
#' facto_summarize(res.pca, "var", axes = 1:2)[,-1]
#' # Select the top 5 contributing variables
#' facto_summarize(res.pca, "var", axes = 1:2,
#'            select = list(contrib = 5))[,-1]
#' # Select variables with cos2 >= 0.6
#' facto_summarize(res.pca, "var", axes = 1:2,
#'            select = list(cos2 = 0.6))[,-1]
#' # Select by names
#' facto_summarize(res.pca, "var", axes = 1:2,
#'      select = list(name = c("X100m", "Discus", "Javeline")))[,-1]
#'            
#' # Summarize individuals on axes 1:2
#' facto_summarize(res.pca, "ind", axes = 1:2)[,-1]
#' 
#' # Correspondence Analysis
#' # ++++++++++++++++++++++++++
#' # Install and load FactoMineR to compute CA
#' # install.packages("FactoMineR")
#' library("FactoMineR")
#' data("housetasks")
#' res.ca <- CA(housetasks, graph = FALSE)
#' # Summarize row variables on axes 1:2
#' facto_summarize(res.ca, "row", axes = 1:2)[,-1]
#' # Summarize column variables on axes 1:2
#' facto_summarize(res.ca, "col", axes = 1:2)[,-1]
#' 
#' # Multiple Correspondence Analysis
#' # +++++++++++++++++++++++++++++++++
#' library(FactoMineR)
#' data(poison)
#' res.mca <- MCA(poison, quanti.sup = 1:2, 
#'               quali.sup = 3:4, graph=FALSE)
#' # Summarize variables on axes 1:2
#' res <- facto_summarize(res.mca, "var", axes = 1:2)
#' head(res)
#' # Summarize individuals on axes 1:2
#' res <- facto_summarize(res.mca, "ind", axes = 1:2)
#' head(res)
#' 
#' # Multiple factor Analysis
#' # +++++++++++++++++++++++++++++++++
#' library(FactoMineR)
#' data(poison)
#' res.mfa <- MFA(poison, group=c(2,2,5,6), type=c("s","n","n","n"),
#'                name.group=c("desc","desc2","symptom","eat"),
#'                num.group.sup=1:2, graph=FALSE)
#' # Summarize categorcial variables on axes 1:2
#' res <- facto_summarize(res.mfa, "quali.var", axes = 1:2)
#' head(res)
#' # Summarize individuals on axes 1:2
#' res <- facto_summarize(res.mfa, "ind", axes = 1:2)
#' head(res)
#' @export
facto_summarize <- function(X, element, node.level = 1, group.names, 
                            result = c("coord", "cos2", "contrib"),
                            axes=1:2, select = NULL)
                            
  { 
  # check element
  allowed_elmts <- c("row", "col", "var", "ind", "quanti.var", "quali.var",
                     "mca.cor", "quanti.sup",  "group", "partial.axes", "partial.node")
  if(!element %in% allowed_elmts) stop("Can't handle element = '", element, "'") 
  if(element %in% c("mca.cor", "quanti.sup")) {
    if(!inherits(X, "MCA")) stop("element = 'mca_cor' is supported only for FactoMineR::MCA().")
    result <- NULL
  }
  
  # Check and get the classe of X
  facto_class <- .get_facto_class(X)
  # Extract the element
  element <- element[1]
  elmt <- switch(facto_class,
                 CA = get_ca(X, element),
                 PCA = get_pca(X, element),
                 MCA = get_mca(X, element),
                 FAMD = get_famd(X, element),
                 MFA = get_mfa(X, element),
                 HMFA = get_hmfa(X, element)
                 )
  
  # Check axes
  if(inherits(elmt, "hmfa_partial"))
    ndim <- ncol(elmt[[1]])
  else
    ndim <- ncol(elmt$coord)
  if(max(axes) > ndim)
    stop("The value of the argument axes is incorrect. ",
         "The number of axes in the data is: ", ncol(elmt$coord), 
         ". Please try again with axes between 1 - ", ncol(elmt$coord))
  
  # Summarize the result
  res = NULL
  if(element %in% c("mca.cor", "quanti.sup")) res <- elmt$coord
  
  # 1.Extract the coordinates x, y and coord
  if("coord" %in% result){
    dd <- data.frame(elmt$coord[, axes, drop=FALSE], stringsAsFactors = TRUE)
    coord <- apply(dd^2, 1, sum) # x^2 + y2 + ...
    res = cbind(dd, coord = coord)
  }
  
  # 2. Extract the cos2
  if("cos2" %in% result){
    cos2 <- elmt$cos2[, axes]
    if(length(axes) > 1) cos2 <- apply(cos2, 1, sum, na.rm=TRUE)
    res <- cbind(res, cos2 = cos2)
  }
  
  # 3. Extract the contribution
  if("contrib" %in% result){
    contrib <- elmt$contrib[, axes]
    if(length(axes) > 1) {
      eig <- get_eigenvalue(X)[axes,1]
      # Adjust variable contributions by the Dimension eigenvalues
      contrib <- t(apply(contrib, 1, 
                         function(var.contrib, pc.eig){var.contrib*pc.eig},
                         eig))
      contrib <-apply(contrib, 1, sum)/sum(eig)
    }
    res <- cbind(res, contrib = contrib)
  }
  
  # 4.Extract the coordinates x, y and coord partial - MFA
  if("coord.partial" %in% result){
    dd <- data.frame(elmt$coord.partiel[, axes, drop=FALSE], stringsAsFactors = TRUE)
    # groupnames 
    groupnames <- lapply(rownames(dd), 
                          function(x){
                            # split at the first instance of "."
                            str_split <- strsplit(sub(".", "\01", x, fixed = TRUE), "\01", fixed = TRUE)
                            unlist(str_split)
                          }
                    )
    groupnames <- as.data.frame(do.call(rbind, groupnames), stringsAsFactors = TRUE)
    colnames(groupnames) <- c("name", "group.name")
    coord.partial <- apply(dd^2, 1, sum) # x^2 + y2 + ...
    res.partial <- data.frame(groupnames, dd, coord.partial, stringsAsFactors = TRUE)
  }
  
  # 5. Extract the coordinates x, y and coord partial - HMFA
  if("coord.node.partial" %in% result){
    # Select hierarchical node
    node <- as.data.frame(elmt[[node.level]], stringsAsFactors = TRUE)
    name <- rep(rownames(node), length(group.names))
    # Prepare data set
    dim.group <- dim.names <- dd <- coord.partial <- dim.coord <- dim.name <- NULL
    for(i in axes[1]:length(axes)) {
      dim.group <- NULL
      for(j in 1:length(group.names)) {
        dim.name <- paste0("Dim", axes[i], ".", j)
        dim.coord <- abind::abind(dim.coord, node[,dim.name])
        dim.group <- c(dim.group, rep(group.names[j], length(node[,dim.name])))
      }
      dim.names <- c(dim.names, paste0("Dim", axes[i]))
      dd <- cbind(dd, dim.coord)
      dim.coord <- NULL
    }
    colnames(dd) <- dim.names
    coord.partial <- apply(dd^2, 1, sum) # x^2 + y2 + ...
    res.partial <- data.frame(group.name = dim.group, name, dd, coord.partial, stringsAsFactors = TRUE)
  }
  
  if("coord.node.partial" %in% result) 
    res <- res.partial
  else {
    name <- rownames(elmt$coord)
    if(is.null(name)) name <- as.character(1:nrow(elmt$coord))
    name <- as.character(name)
    res <- cbind.data.frame(name = name, res, stringsAsFactors = TRUE)
    rownames(res) <- name
    if(!is.null(select)) res <- .select(res, select)
    if("coord.partial" %in% result){
    res = list(res = res, res.partial = res.partial)
    }
  }
  
  res
}

```

