# Direct shotgun metagenomics captures species abundance of honey samples
# R script author: Anastasios Galanis, 2020
# This script will INSTALL packages that have not been previously installed. 
# If you do not wish to install new packages, please avoid running this script.

# This script will reproduce Figure X for function of metagenome across samples and methods
# This script is written in R version 3.6.3

# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('here')) install.packages('here'); library('here')
if (!require('pheatmap')) install.packages('pheatmap'); library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
if (!require("reshape2")) install.packages("reshape2"); library('reshape2')
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('VennDiagram')) install.packages('VennDiagram'); library('VennDiagram')
if (!require('randomcoloR')) install.packages('randomcoloR'); library('randomcoloR')


# Import files
import_go_files <- list.files(path = "./Figures/Figure_7/gos_aligned",pattern = "\\.fasta.txt",full.names = T)

go_files <- lapply(import_go_files, function(tble) {
  read.delim(file = tble, 
             sep = '\t',
             header = TRUE,
             strip.white = TRUE)
})

sample_names <- c("SM_H5","DirectSM_H5","SM_H4","SM_H6", "SM_H7","DirectSM_H4","DirectSM_H6","DirectSM_H7")

sample_names <- c("DirectSM_H4","DirectSM_H5","DirectSM_H6","DirectSM_H7","SM_H4","SM_H5","SM_H6", "SM_H7")

# This will name each element (or dataframe) of the list
# according to the filename it originated from.
go_files <- setNames(go_files, sample_names)

df_naming <- c("GO_annotation","Abundance")
go_files = lapply(go_files,setNames,df_naming)

all_go_files <- lapply(names(go_files), function(x){
  colnames(go_files[[x]]) <- c("GO_annotation",x)
  go_files[[x]]
})
names(all_go_files) <- names(go_files) 


#%>% dplyr::select(GO_annotation, everything()) %>% mutate_all(~replace(., is.na(.),0))


hives_metadata <- read.csv("./Figures/Figure_3/Data_fig_3/metadata_hives.csv")
hives_metadata_new <- hives_metadata %>% column_to_rownames(var="X")

go_annotations <- go_annotations %>% column_to_rownames(var="GO_annotation")

# Reorder according to the order in the metadata file
go_annotations <- go_annotations[,c(6,2,7,8,3,1,4,5)]

# These are all regular expressions in order to extract the information from the strings
# Each string contains: the taxonomic ID of species, the GO category/function, and the GO function itself
proper_naming_list <- function(df) {
  df$species <- str_match(df$GO_annotation, "\\|([^_]+)")
  df$functionality <- str_match(df$GO_annotation, "\\[([^\\]]+)")
  df$GO_annotations <- str_match(df$GO_annotation, "\\s\\w\\s*(.*?)\\s*[^\\|]+")
  
  df$functionality <- gsub("^.*?\\[","", df$functionality)
  df$species <- gsub("^.*?\\|","", df$species)
  df$GO_annotations <- gsub("^\\s", "",df$GO_annotations)
  df5 <- as.data.frame(df$species)
  df6 <- as.data.frame(df$GO_annotations)
  df$GO_species <- paste0(df$GO_annotations[,1],"|",df$species[,1])
  df$species <- df$species[,1]
  df$functionality <- df$functionality[,1]
  df$GO_annotations <- df$GO_annotations[,1]
  df <- df[,c(2,5)]
  df <- df %>% group_by(GO_annotations) %>% dplyr::summarise_each(sum)
  ;
  return(df)
}


go_naming_list <- lapply(all_go_files,proper_naming_list)
go_annotations <- go_naming_list %>% purrr::reduce(full_join, by = "GO_annotations")

go_annotations <- go_annotations[!is.na(go_annotations$GO_annotations),]
go_annotations <- go_annotations %>% mutate_all(~replace(., is.na(.),0)) %>% as.data.frame(.)
go_annotations <- go_annotations %>% column_to_rownames(var = "GO_annotations")


# Remove the first 15 rows because they have no GO annotation
# Also remove the first column
go_annotations <- go_annotations[-c(1:15),-1]

# Add the species names
go_annotations$species_names <- getTaxonomy(go_annotations$species[,1],desiredTaxa = "species",'nameNode.sqlite')

go_annotations_deseq <- go_annotations[,c(1:8,)]

# DESeq2 normalisation
Hives_dds_functional <- DESeqDataSetFromMatrix(countData = go_annotations, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_functional <- estimateSizeFactors(Hives_dds_functional,type = "ratio")
Hives_normalised_counts_functional <- counts(Hives_dds_RLE_functional, normalized = TRUE)
Hives_counts_vst_functional <- varianceStabilizingTransformation(Hives_dds_RLE_functional, blind = FALSE)

ordered_counts_functional <- order(rowMeans(counts(Hives_dds_RLE_functional,normalized=TRUE)), decreasing=TRUE)

# Draw heatmap of all go functions
final_heatmap_functional <- pheatmap(assay(Hives_counts_vst_functional)[ordered_counts_functional,],cluster_rows = FALSE, show_rownames = FALSE, clustering_distance_cols = "correlation", cluster_cols = F, show_colnames = T)

ggsave(plot = final_heatmap_functional, filename="./Figures/Figure_3/functional_heatmap_significant.pdf")

# Volcano plot to evaluate whether some differ by method 
get_volcano_plot <- function(dds_rle_object, .contrast) {
  object <- DESeq(dds_rle_object,test = "LRT", reduced = ~Method, full = ~Method+Season)
  res_dds <- results(object, .contrast)
  res <- lfcShrink(object,contrast = .contrast, res=res_dds,type = 'normal')
  EnhancedVolcano(res, lab = NA, x = 'log2FoldChange',y= 'pvalue', FCcutoff = 1,
                  colAlpha = 2,labSize = 2, xlim = c(-2,2))
}

method_volcano  <- get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Method','SM','Direct_SM'))

# By season
season_volcano <- get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Season','July','November'))


# Get top 12 most abundant GOs per sample
normalised_functional <- Hives_normalised_counts_functional %>% as.data.frame(.)
normalised_functional <- normalised_functional[,1:8] %>% mutate_all(.,funs((./sum(.))*100))
normalised_functional$GO_annotation <- rownames(Hives_normalised_counts_functional)


Hive4_go <- normalised_functional[,c(1,5,9)]
Hive5_go <- normalised_functional[,c(2,6,9)]
Hive6_go <- normalised_functional[,c(3,7,9)]
Hive7_go <- normalised_functional[,c(4,8,9)]

Hive4_go_ordered <- (Hive4_go[order(Hive4_go$DirectSM_H4, decreasing = T),])[1:12,]
Hive5_go_ordered <- (Hive5_go[order(Hive5_go$DirectSM_H5, decreasing = T),])[1:12,]
Hive6_go_ordered <- (Hive6_go[order(Hive6_go$DirectSM_H6, decreasing = T),])[1:12,]
Hive7_go_ordered <- (Hive7_go[order(Hive7_go$DirectSM_H7, decreasing = T),])[1:12,]

go_list <- list(Hive4_go_ordered,Hive5_go_ordered,Hive6_go_ordered,Hive7_go_ordered)
go_list_ordered <- go_list %>% purrr::reduce(full_join,by="GO_annotation")
go_list_ordered <- go_list_ordered %>% mutate_if(is.numeric,~replace(., is.na(.),0))

sum_abundance_go <- go_list_ordered %>% dplyr::select(.,c("GO_annotation",(dplyr::select_if(.,is.numeric) %>% colnames()))) %>% dplyr::group_by(GO_annotation) %>%  dplyr::summarise_each(sum) %>% filter(rowSums(dplyr::select(., -GO_annotation)) > 0) %>% t(.) %>% as.data.frame(.) %>% janitor::row_to_names(.,row_number = 1) %>% tibble::rownames_to_column(var="Method") %>% reshape2::melt(., id = "Method")

sum_abundance_go$value <- as.numeric(sum_abundance_go$value)
sum_abundance_go$Method <- str_replace(sum_abundance_go$Method, pattern = "_", replacement = " ")
sum_abundance_go$Method <- factor(sum_abundance_go$Method, levels = c("DirectSM H5","SM H5","DirectSM H6","SM H6","DirectSM H7", "SM H7","DirectSM H4","SM H4"))
sum_abundance_go$variable <- as.factor(sum_abundance_go$variable)


palette <- distinctColorPalette(23)


sum_go_terms_plot <- ggplot(sum_abundance_go, aes(fill=variable, y=value, x=Method)) + labs(x="",y="Relative abundance (%)", fill = "GO term") +
  geom_bar(position="fill", stat="identity") + scale_fill_manual(values = palette) + theme_bw() + theme(axis.text.x = element_text(angle = 45, size = 10)) + scale_y_continuous(breaks = c(0,0.25,0.50,0.75,1), labels = c(0,25,50,75,100))



ggsave(plot = sum_go_terms_plot, filename = "./Figures/Figure_7/sum_abundance_go_terms.pdf")



ann_colors = list(
  Domain = c(Bacteria = "#E6AB02", Viruses = "#eb53a1", Eukaryota = "#7570B3", Viridiplantae = "#1B9E77", Archaea = "#D95F02"),
  Season = c(May = "#5cb300", July = "#e8df2a", November = "#8f7c56"))


plotDiffAbund_functional <- function(colNums, DESeq_RLE_object, title, pathcsv) {
  
  dds_object <- DESeq(DESeq_RLE_object, test = "LRT", reduced = ~Method, full = ~Method+Season)
  rld <- rlog(dds_object, blind=T)
  results <- subset(results(dds_object), padj <=1)
  
  results_export <- as.data.frame(rownames(results))
  colnames(results_export) <- c("Taxonomic_ID")
  write.csv(results_export,pathcsv)
  
  # make the lists
  upgenes <- rownames(head(results[ order( results$log2FoldChange ), ], n=20))

  # this gives us the rows we want
  rows <- match(upgenes, row.names(rld))
  mat <- assay(rld)[rows,c(1:8)]
  mat <- mat - rowMeans(mat)
  
  # the labels are hard coded at the moment :(
  df <- as.data.frame(colData(rld)[c("Season")])
  pheatmap(mat, fontsize=15, annotation_colors = ann_colors, cluster_rows = FALSE, show_rownames = TRUE, height = 100, angle_col = "270", cluster_cols = TRUE, show_colnames = TRUE, border_color = NA, annotation_col = df, labels_col = c("DirectSM H4","DirectSM H5","DirectSM H6" ,"DirectSM H7","SM H4", "SM H5","SM H6","SM H7"), scale = 'row')
}


functional_significant <- plotDiffAbund_functional(Hives_dds_RLE_functional,pathcsv = "./Figures/Figure_3/functional_significantly_heatmap_sigspecies.csv", colNums = c(1:8))
ggsave(plot = functional_significant, filename = "./Figures/Figure_3/functional_top20.pdf", height = 10, width = 12)




## DO NOT RUN CODE BELOW
# HAS REMAINED AS LEGACY IN CASE I NEED TO REVERT BACK



go_mapping <- as.data.frame(str_extract(go_annotations$GO_annotation, pattern = "^.*?\\]"))
colnames(go_mapping) <- c("Function")
go_mapping$Function <- gsub("^.*?\\[","", go_mapping$Function)
go_mapping$Function <- str_remove(go_mapping$Function, pattern = "]")

go_annotations$GO_annotation <- gsub("^.*?\\]","", go_annotations$GO_annotation) %>% str_trim(.,side = "left")
go_mapping$GO <- as.factor(go_annotations$GO_annotation)
go_mapping <- go_mapping %>% column_to_rownames(var="GO")





# Calculate difference between SM and DSM for each hive individually
df_humann_matrix <- as.data.frame(matrix_humann2)
Hive_4_fun <- df_humann_matrix$DSM_H4 - df_humann_matrix$SM_H4
Hive_5_fun <- df_humann_matrix$DSM_H5 - df_humann_matrix$SM_H5
Hive_6_fun <- df_humann_matrix$DSM_H6 - df_humann_matrix$SM_H6
Hive_7_fun <- df_humann_matrix$DSM_H7 - df_humann_matrix$SM_H7


differences <- as.data.frame(cbind(Hive_4_fun,Hive_5_fun,Hive_6_fun,Hive_7_fun))
differences$pathways <- rownames(df_humann_matrix)

differences_for_boxplot <- melt(differences)

differences_boxplot <-  ggplot(differences_for_boxplot, aes(x=pathways, y=value)) +
  geom_boxplot() +
  scale_fill_viridis(discrete = TRUE, alpha=0.6) +
  geom_jitter(color="black", size=0.4, alpha=0.9) +
  theme_minimal() +
  theme(
    legend.position="none",
    plot.title = element_text(size=11),
    axis.text.y = element_blank()
    ) + xlab("") + ylab ("DSM vs SM difference (%)") + coord_flip()


# Per species FUNCTIONAL diversity 
go_names <- read.table('./Figures/Figure_7/combined_tables_with_go_names.tsv',
                        row.names=1, header=T, sep='\t', 
                        comment.char='', quote='')


# Remove the suffix from the sample labels
names(go_names) <- gsub('_Abundance.RPKs', '', names(go_names))

go_names_deseq <- round(go_names, digits = 0)

Hives_dds_go <- DESeqDataSetFromMatrix(countData = go_names_deseq, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_go <- estimateSizeFactors(Hives_dds_go,type = "ratio")
Hives_normalised_counts_go <- counts(Hives_dds_RLE_go, normalized = TRUE)

# Custom function to create dataframe with per species functional diversity so that we can
# later plot it .
species_functional_diversity <- function(normalised_counts) {
  go_names_normalised <- as.data.frame(normalised_counts) %>% rownames_to_column(var="species")
  go_names_normalised$go_function <- go_names_normalised$species 
  go_names_normalised$species <- gsub(".*[__]([^.]+)[.].*", "\\1", go_names_normalised$species)
  go_names_normalised$go_function <- gsub("\\|.*", "", go_names_normalised$go_function)
  go_names_normalised <- go_names_normalised[!grepl("GO:", go_names_normalised$species),]
  go_names_normalised <- go_names_normalised[!grepl("UNMAPPED", go_names_normalised$species),]
  go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$species),]
  go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$go_function),]
}


functional_diversity_samples <- species_functional_diversity(Hives_normalised_counts_go)

# Custom function to return top X go_functions
get_most_abundant_go <- function(normalised_counts, top_x_gos) {
  go_names_normalised_x <- as.data.frame(normalised_counts) %>% rownames_to_column(var="species")
  go_names_normalised_x <- go_names_normalised_x[!grepl("g_", go_names_normalised_x$species),]
  go_names_normalised_x$rowsum <- rowSums(go_names_normalised_x[,-1])
  go_names_normalised_x <- go_names_normalised_x[-c(1,2),]
  go_names_normalised_x <- go_names_normalised_x[order(go_names_normalised_x$rowsum, decreasing = T),]
  go_top_x <- go_names_normalised_x$species[top_x_gos]
}

top_20_gos <- get_most_abundant_go(Hives_normalised_counts_go, top_x_gos = c(1:20))

go_for_plot <- reshape2::melt(functional_diversity_samples)

go_for_plot3 <- go_for_plot2[go_for_plot2$go_function %in% top_20_gos,]
go_for_plot3$go_function <-  go_for_plot3$go_function %>% str_replace(".*\\] ","")

functional_diversity_per_species <- ggplot(go_for_plot3, aes(x=species, y=value, fill = go_function)) + geom_bar(stat = "identity", position = "fill") + theme_minimal() + theme(legend.position="right", legend.text = element_text(size=8), axis.text.x = element_text(face = "italic", angle = 45, hjust = 1, size = 10), axis.title.x = element_blank()) + guides(fill=guide_legend(ncol=2)) + scale_fill_viridis_d(option = "magma") + ylab("GO function (%)") + labs(fill = "GO function") + scale_y_continuous(labels = c(0,25,50,75,100))
ggsave(plot = functional_diversity_per_species, filename = "./Figures/Figure_7/functional_diversity_per_species.pdf", width = 7.5)


# Process previous honey samples
go_names_previous <- read.table('./Figures/Figure_7/combined_tables_with_go_names_previous.tsv',
                       row.names=1, header=T, sep='\t', 
                       comment.char='', quote='')


# Remove the suffix from the sample labels
names(go_names_previous) <- gsub('_Abundance.RPKs', '', names(go_names_previous))
previous_metadata <- read.csv("./Figures/Figure_7/metadata_previous.csv")
previous_metadata <- previous_metadata %>% column_to_rownames(var="X")

go_names_deseq_previous <- round(go_names_previous, digits = 0)


Hives_dds_go_previous <- DESeqDataSetFromMatrix(countData = go_names_deseq_previous, colData = previous_metadata, design = ~Source, tidy = F)
Hives_dds_RLE_go_previous <- estimateSizeFactors(Hives_dds_go_previous,type = "ratio")
Hives_normalised_counts_go_previous <- counts(Hives_dds_RLE_go_previous, normalized = TRUE)


previous_functional_diversity <- species_functional_diversity(go_names_deseq_previous)
top_30_previous <- get_most_abundant_go(Hives_normalised_counts_go_previous, top_x_gos = c(1:20))

# Get the 30 most abundant functions 


go_for_plot_previous <- reshape2::melt(previous_functional_diversity)

go_for_plot_previous2 <- go_for_plot_previous[go_for_plot_previous$go_function %in% top_30_previous,]
go_for_plot_previous2$go_function <-  go_for_plot_previous2$go_function %>% str_replace(".*\\] ","")


functional_diversity_per_species_previous <- ggplot(go_for_plot_previous2, aes(x=species, y=value, fill = go_function)) + geom_bar(stat = "identity", position = "fill") + theme_minimal() + theme(legend.position="right", legend.text = element_text(size=8), axis.text.x = element_text(face = "italic", angle = 45, hjust = 1, size = 10), axis.title.x = element_blank()) + guides(fill=guide_legend(ncol=2)) + scale_fill_viridis_d(option = "magma") + ylab("GO function (%)") + labs(fill = "GO function") + scale_y_continuous(labels = c(0,25,50,75,100))
ggsave(plot = functional_diversity_per_species_previous, filename = "./Figures/Figure_7/functional_diversity_per_species_previous.pdf", width = 7.5)


# Create venn diagram to compare the gos from our samples to the previously published ones
venn.diagram(
  x = list(get_most_abundant_go(Hives_normalised_counts_go, top_x_gos = c(1:1000)), get_most_abundant_go(Hives_normalised_counts_go_previous, top_x_gos = c(1:1000))),
  category.names = c("DSM+SM samples" , "Published datasets"),
  filename = './Figures/Figure_7/venndiagram_gos_smdsm_and_previousdatasets.png',
  output=T,
  imagetype="png" ,
  height = 800 , 
  width = 800 , 
  resolution = 300,
  compression = "lzw",
  
  # Circles
  lwd = 2,
  lty = 1,
  fill = viridis_pal(alpha = 0.3)(2),
  col = viridis_pal(alpha = 0.5)(2),

  # Numbers
  cex = .6,
  fontface = "bold",
  fontfamily = "sans",
  
  # Set names
  cat.cex = 0.6,
  cat.fontface = "bold",
  cat.default.pos = "outer",
  cat.pos = c(-27, 27),
  cat.dist = c(0.055, 0.055),
  cat.fontfamily = "sans",
  cat.col = viridis_pal()(2)
)
