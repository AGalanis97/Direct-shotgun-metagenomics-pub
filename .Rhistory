p3 <- p2  + geom_cladelabel(node = 486, color ="#CC4678FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 543, color = "#73D055FF", align = T, label = "", barsize = 3, offset = 0) + geom_cladelabel(node = 578, color = "#0D0887FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 479, color = "#F0F921FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 575, color = "#ad05f5", align = T, label = "", barsize = 3)
p3
# generate a circular tree
circ <- ggtree(tree1, branch.length = "none", layout = "circular", ladderize = TRUE) + geom_tiplab(size=1.2)
# Attach the data to the tree
circ2 <- circ %<+% colouring + aes(color = I(color))
circ2
# Change the rownames of the dataframe so they match the tree
rownames(differences) <- tree1$tip.label
# Now we set an arbitrary limit of 10000 reads difference between the libraries. This should result in approximately 2% difference in abundance
differences[differences > 10000] <- 10000
differences[differences < -10000] <- -10000
# We can now build the heatmap
p2 <- gheatmap(circ2, differences, colnames_angle=0, colnames_offset_y = 0, width = 0.3, colnames = F) + scale_fill_gradientn(colours =c("#440154FF","white","#FDE725FF"),breaks = c(-10000,0,10000), labels=c("SM","","DSM")) + theme(legend.position = "bottom", legend.title.align = 0.5) + guides(fill = guide_colourbar(barwidth = 5, ticks = FALSE, title = "Read difference: \n-10000   +10000", title.position = "top"))
# Add annotation to the Domains as we've done so far
p3 <- p2  + geom_cladelabel(node = 486, color ="#CC4678FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 543, color = "#73D055FF", align = T, label = "", barsize = 3, offset = 0) + geom_cladelabel(node = 578, color = "#0D0887FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 479, color = "#F0F921FF", align = T, label = "", barsize = 3) + geom_cladelabel(node = 575, color = "#ad05f5", align = T, label = "", barsize = 3)
p3
Family_counts_DSM <- Rounded_counts_with_tax[,c(2:5)]
Family_counts_SM <- Rounded_counts_with_tax[,c(6:9)]
Family_counts_SM$Sum_SM <- rowSums(Family_counts_SM)
Family_counts_DSM$Sum_DSM <- rowSums(Family_counts_DSM)
differences <- Family_counts_DSM$Sum_DSM - Family_counts_SM$Sum_SM
differences <- as.data.frame(differences)
View(differences)
View(Family_counts_DSM)
View(Family_counts_SM)
View(Family_counts_DSM)
View(Family_counts_SM)
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('here')) install.packages('here'): library('here')
if (!require('ggplot2')) install.packages('ggplot2'): library('ggplot2')
if (!require('reshape2')) install.packages('reshape2'): library('reshape2')
setwd(here::here())
Counts_with_taxonomy <- read.csv("./Figures/Figure_4/Data_fig_4/normalised_counts_species.csv")
# Counts_with_taxonomy <- Counts_with_taxonomy %>% tibble::rownames_to_column(var = "Taxonomic_ID") %>% filter(Phylum == "Streptophyta",) %>% tibble::column_to_rownames("Taxonomic_ID")
Hive4_comparison <- Counts_with_taxonomy %>% select(c("Taxonomic_ID","DirectSM_H4","SM_H4")) %>% mutate(Presence = case_when(DirectSM_H4 == 0 & SM_H4 != 0 ~  "Only SM", DirectSM_H4 != 0 & SM_H4 == 0 ~  "Only DSM",DirectSM_H4 != 0 & SM_H4 != 0 ~  "Both", DirectSM_H4 == 0 & SM_H4 == 0 ~ "Both")) %>% filter(!is.na(Presence)) %>% tibble::column_to_rownames(var="Taxonomic_ID")
Counts_with_taxonomy <- read.csv("./Figures/Figure_4/Data_fig_4/normalised_counts_species.csv")
setwd("~/Documents/GitHub/Direct-shotgun-metagenomics-pub")
Counts_with_taxonomy <- read.csv("./Figures/Figure_4/Data_fig_4/normalised_counts_species.csv")
Hive4_comparison <- Counts_with_taxonomy %>% select(c("Taxonomic_ID","DirectSM_H4","SM_H4")) %>% mutate(Presence = case_when(DirectSM_H4 == 0 & SM_H4 != 0 ~  "Only SM", DirectSM_H4 != 0 & SM_H4 == 0 ~  "Only DSM",DirectSM_H4 != 0 & SM_H4 != 0 ~  "Both", DirectSM_H4 == 0 & SM_H4 == 0 ~ "Both")) %>% filter(!is.na(Presence)) %>% tibble::column_to_rownames(var="Taxonomic_ID")
Hive5_comparison <- Counts_with_taxonomy %>% select(c("Taxonomic_ID","DirectSM_H5","SM_H5")) %>% mutate(Presence = case_when(DirectSM_H5 == 0 & SM_H5 != 0 ~  "Only SM", DirectSM_H5 != 0 & SM_H5 == 0 ~  "Only DSM",DirectSM_H5 != 0 & SM_H5 != 0 ~  "Both",DirectSM_H5 == 0 & SM_H5 == 0 ~ "Both")) %>% filter(!is.na(Presence)) %>% tibble::column_to_rownames(var="Taxonomic_ID")
Hive6_comparison <- Counts_with_taxonomy %>% select(c("Taxonomic_ID","DirectSM_H6","SM_H6")) %>% mutate(Presence = case_when(DirectSM_H6 == 0 & SM_H6 != 0 ~  "Only SM", DirectSM_H6 != 0 & SM_H6 == 0 ~  "Only DSM",DirectSM_H6 != 0 & SM_H6 != 0 ~  "Both",DirectSM_H6 == 0 & SM_H6 == 0 ~ "Both")) %>% filter(!is.na(Presence)) %>% tibble::column_to_rownames(var="Taxonomic_ID")
Hive7_comparison <- Counts_with_taxonomy %>% select(c("Taxonomic_ID","DirectSM_H7","SM_H7")) %>% mutate(Presence = case_when(DirectSM_H7 == 0 & SM_H7 != 0 ~  "Only SM", DirectSM_H7 != 0 & SM_H7 == 0 ~  "Only DSM",DirectSM_H7 != 0 & SM_H7 != 0 ~  "Both",DirectSM_H7 == 0 & SM_H7 == 0 ~ "Both")) %>% filter(!is.na(Presence)) %>% tibble::column_to_rownames(var="Taxonomic_ID")
View(Hive4_comparison)
View(Counts_with_taxonomy)
Hive4_barplot <- c("Hive 4",sum(Hive4_comparison$Presence == "Only DSM"),sum(Hive4_comparison$Presence == "Only SM"),sum(Hive4_comparison$Presence == "Both"))
Hive5_barplot <- c("Hive 5",sum(Hive5_comparison$Presence == "Only DSM"),sum(Hive5_comparison$Presence == "Only SM"),sum(Hive5_comparison$Presence == "Both"))
Hive6_barplot <- c("Hive 6",sum(Hive6_comparison$Presence == "Only DSM"),sum(Hive6_comparison$Presence == "Only SM"),sum(Hive6_comparison$Presence == "Both"))
Hive7_barplot <- c("Hive 7",sum(Hive7_comparison$Presence == "Only DSM"),sum(Hive7_comparison$Presence == "Only SM"),sum(Hive7_comparison$Presence == "Both"))
data_method_to_reshape <- rbind(Hive4_barplot,Hive5_barplot,Hive6_barplot,Hive7_barplot) %>% as.data.frame() %>% remove_rownames() %>% dplyr::rename(Hive = V1) %>% dplyr::rename(Only_DSM = V2) %>% dplyr::rename(Only_SM = V3) %>% dplyr::rename(Both = V4)
data_method_per_hive <- melt(data_method_to_reshape, id.vars = "Hive") %>% dplyr::rename(Method = variable)
data_method_per_hive$value = as.numeric(data_method_per_hive$value)
barplot_comparison_method_per_hive <- ggplot(data_method_per_hive, aes(x=Hive, y=value, fill=Method)) + geom_bar(position = 'fill',stat = "identity", width = 0.5) + theme_bw() + labs(x="",y="Identified (%)") + scale_fill_viridis_d(labels = c("Only DirectSM","Only SM","Both")) + scale_y_continuous(labels = c(0,25,50,75,100)) + theme(text = element_text(size = 15), aspect.ratio = 0.3, legend.title = element_text(size = 13),
legend.text = element_text(size = 10), legend.position = 'top') + coord_flip()
barplot_comparison_method_per_hive
barplot_comparison_method_per_hive <- ggplot(data_method_per_hive, aes(x=Hive, y=value, fill=Method)) + geom_bar(position = 'fill',stat = "identity", width = 0.5) + theme_bw() + labs(x="",y="Identified (%)") + scale_fill_viridis_d(labels = c("Only DirectSM","Only SM","Both")) + scale_y_continuous(labels = c(0,25,50,75,100)) +
theme(text = element_text(size = 15), aspect.ratio = 0.3, legend.title = element_blank(),legend.text = element_text(size = 10), legend.position = 'top') +
coord_flip()
barplot_comparison_method_per_hive
# We apply the RLE normalisation but using the Method + Season so we can observe seasonal effects and do methodological validation
Hives_dds_family <- DESeqDataSetFromMatrix(countData = Hives_comparison_family, colData = hives_metadata, design = ~Method + Season, tidy = TRUE)
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('taxonomizr')) install.packages('taxonomizr'); library('taxonomizr')
if (!require('here')) install.packages('here'): library('here')
# Taxonomizr will return the taxonomy for each species. However, this requires that a database is built locally (requires 60 GB of space).
# prepareDatabase('nameNode.sqlite')
# This process will take over 3 hours on a regular laptop/PC.
# from here: and simply unzip it in the cloned repository. Place it at the top level, honeyDSM-seq and not in the subfolders.
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('pheatmap')) install.packages('pheatmap'): library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
# if (!require("lasso2")) install.packages("lasso2"): library('lasso2')
# Requires R 4.0 now. Install from archive.
data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('taxonomizr')) install.packages('taxonomizr'); library('taxonomizr')
if (!require('here')) install.packages('here'): library('here')
# Taxonomizr will return the taxonomy for each species. However, this requires that a database is built locally (requires 60 GB of space).
# prepareDatabase('nameNode.sqlite')
# This process will take over 3 hours on a regular laptop/PC.
# from here: and simply unzip it in the cloned repository. Place it at the top level, honeyDSM-seq and not in the subfolders.
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('pheatmap')) install.packages('pheatmap'): library('pheatmap')
# Taxonomizr will return the taxonomy for each species. However, this requires that a database is built locally (requires 60 GB of space).
# prepareDatabase('nameNode.sqlite')
# This process will take over 3 hours on a regular laptop/PC.
# from here: and simply unzip it in the cloned repository. Place it at the top level, honeyDSM-seq and not in the subfolders.
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('pheatmap')) install.packages('pheatmap'): library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"
# Vector with the column names of the kraken2 output
kraken2_output_names <- c("Reads_assigned_rooted_at_taxon", "Reads_assigned_directly_to_taxon","Rank_code","Taxonomic_ID","Name")
# Import the kraken2 output
import_kraken2_files <- list.files(path = data_path,pattern = "\\.kraken2",full.names = T)
data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"
# Vector with the column names of the kraken2 output
kraken2_output_names <- c("Reads_assigned_rooted_at_taxon", "Reads_assigned_directly_to_taxon","Rank_code","Taxonomic_ID","Name")
# Import the kraken2 output
import_kraken2_files <- list.files(path = data_path,pattern = "\\.kraken2",full.names = T)
kraken2_files <- lapply(import_kraken2_files, function(tble) {
read.delim(file = tble,
sep = '\t',
header = FALSE,
strip.white = TRUE)[,-c(1)]
})
naming_list <- list.files(path = data_path,pattern = "\\.kraken2")
kraken2_files <- setNames(kraken2_files, substring(naming_list, first  = 1, last = nchar(naming_list) -8))
kraken2_files = lapply(kraken2_files,setNames,kraken2_output_names)
kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files = lapply(kraken2_files, classification_ranks)
get_totals_per_sample <- function(df) {
classified <- df[2,1]
}
all_reads_per_sample <- rbind(family_per_sample,genus_per_sample,species_per_sample)
family_per_sample <- lapply(kraken2_files_family,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
genus_per_sample <-lapply(kraken2_files_genus,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
species_per_sample <- lapply(kraken2_files_species,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
kraken2_files = lapply(kraken2_files, classification_ranks)
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files <- setNames(kraken2_files, substring(naming_list, first  = 1, last = nchar(naming_list) -8))
kraken2_files = lapply(kraken2_files,setNames,kraken2_output_names)
kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)
data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"
# Vector with the column names of the kraken2 output
kraken2_output_names <- c("Reads_assigned_rooted_at_taxon", "Reads_assigned_directly_to_taxon","Rank_code","Taxonomic_ID","Name")
# Import the kraken2 output
import_kraken2_files <- list.files(path = data_path,pattern = "\\.kraken2",full.names = T)
kraken2_files <- lapply(import_kraken2_files, function(tble) {
read.delim(file = tble,
sep = '\t',
header = FALSE,
strip.white = TRUE)[,-c(1)]
})
naming_list <- list.files(path = data_path,pattern = "\\.kraken2")
# This will name each element (or dataframe) of the list
# according to the filename it originated from.
kraken2_files <- setNames(kraken2_files, substring(naming_list, first  = 1, last = nchar(naming_list) -8))
kraken2_files = lapply(kraken2_files,setNames,kraken2_output_names)
kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files = lapply(kraken2_files, classification_ranks)
# Filter out human and Drosophila contamination. For human contamination, the Chordata clade is removed to ensure that no false negatives appear.
kraken2_files_family <- kraken2_files %>% lapply(filter, Rank_code == "F") %>% lapply(filter, Name != "Drosophilidae") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_genus <- kraken2_files %>% lapply(filter, Rank_code == "G") %>% lapply(filter, Name != "Drosophila") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_species <- kraken2_files %>% lapply(filter, Rank_code == "S") %>% lapply(filter, Name != "Drosophila melanogaster") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
# This will generate a table with total reads per sample and level
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files = lapply(kraken2_files, classification_ranks)
get_totals_per_sample <- function(df) {
classified <- df[2,1]
}
totals_classified <- lapply(kraken2_files,get_totals_per_sample) %>% do.call(rbind,.) %>% as.data.frame(.)
count_after_filter <- Hives_comparison_species[,-1]
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('taxonomizr')) install.packages('taxonomizr'); library('taxonomizr')
if (!require('here')) install.packages('here'): library('here')
# Taxonomizr will return the taxonomy for each species. However, this requires that a database is built locally (requires 60 GB of space).
# prepareDatabase('nameNode.sqlite')
# This process will take over 3 hours on a regular laptop/PC.
# from here: and simply unzip it in the cloned repository. Place it at the top level, honeyDSM-seq and not in the subfolders.
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('pheatmap')) install.packages('pheatmap'): library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
# if (!require("lasso2")) install.packages("lasso2"): library('lasso2')
# Requires R 4.0 now. Install from archive.
data_path <- "./Figures/Figure_3/Data_fig_3"
output_path <- "./Output_data/Figure_3_output/"
# Vector with the column names of the kraken2 output
kraken2_output_names <- c("Reads_assigned_rooted_at_taxon", "Reads_assigned_directly_to_taxon","Rank_code","Taxonomic_ID","Name")
# Import the kraken2 output
import_kraken2_files <- list.files(path = data_path,pattern = "\\.kraken2",full.names = T)
kraken2_files <- lapply(import_kraken2_files, function(tble) {
read.delim(file = tble,
sep = '\t',
header = FALSE,
strip.white = TRUE)[,-c(1)]
})
naming_list <- list.files(path = data_path,pattern = "\\.kraken2")
# This will name each element (or dataframe) of the list
# according to the filename it originated from.
kraken2_files <- setNames(kraken2_files, substring(naming_list, first  = 1, last = nchar(naming_list) -8))
kraken2_files = lapply(kraken2_files,setNames,kraken2_output_names)
kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files = lapply(kraken2_files, classification_ranks)
# Filter out human and Drosophila contamination. For human contamination, the Chordata clade is removed to ensure that no false negatives appear.
kraken2_files_family <- kraken2_files %>% lapply(filter, Rank_code == "F") %>% lapply(filter, Name != "Drosophilidae") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files = lapply(kraken2_files, classification_ranks)
kraken2_files = lapply(kraken2_files, classification_ranks)
kraken2_files = lapply(kraken2_files, classification_ranks)
# Filter out human and Drosophila contamination. For human contamination, the Chordata clade is removed to ensure that no false negatives appear.
kraken2_files_family <- kraken2_files %>% lapply(filter, Rank_code == "F") %>% lapply(filter, Name != "Drosophilidae") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_genus <- kraken2_files %>% lapply(filter, Rank_code == "G") %>% lapply(filter, Name != "Drosophila") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
kraken2_files_species <- kraken2_files %>% lapply(filter, Rank_code == "S") %>% lapply(filter, Name != "Drosophila melanogaster") %>% lapply(filter, is.na(Phylum)|Phylum != "Chordata")
get_totals_per_sample <- function(df) {
classified <- df[2,1]
}
totals_classified <- lapply(kraken2_files,get_totals_per_sample) %>% do.call(rbind,.) %>% as.data.frame(.)
count_after_filter <- Hives_comparison_species[,-1]
totals_filter <- apply(count_after_filter,2,sum) %>% as.data.frame()
# merge the dataframes and calculate percent
class_filter <- cbind(totals_classified,totals_filter)
colnames(class_filter) <- c("Total","Filtered")
class_filter$Percent <- round((class_filter$Filtered/class_filter$Total)*100, digits = 2)
# This function will grab the number of reads assigned directly to the different levels
get_reads_per_level <- function(df) {
df_1 <-  sum(df$Reads_assigned_directly_to_taxon);
return(df_1)
}
family_per_sample <- lapply(kraken2_files_family,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
genus_per_sample <-lapply(kraken2_files_genus,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
species_per_sample <- lapply(kraken2_files_species,get_reads_per_level) %>% do.call(cbind,.) %>% as.data.frame()
all_reads_per_sample <- rbind(family_per_sample,genus_per_sample,species_per_sample)
all_reads_per_sample$Level <- c("Family","Genus","Species")
# This will only keep the taxonomic ID and number of reads from the table. For Genus and Family the rooted reads are used.
kraken2_files_filter_genus <- lapply(kraken2_files_genus, "[", c(1,4))
kraken2_files_filter_species <- lapply(kraken2_files_species, "[", c(2,4))
kraken2_files_filter_family <- lapply(kraken2_files_family, "[", c(1,4))
# The functions below rename the columns.
Hives_genus <- lapply(names(kraken2_files_filter_genus), function(x){
colnames(kraken2_files_filter_genus[[x]]) <- c(x,"Taxonomic_ID")
kraken2_files_filter_genus[[x]]
})
names(Hives_genus) <- names(kraken2_files_filter_genus)
Hives_species <- lapply(names(kraken2_files_filter_species), function(x){
colnames(kraken2_files_filter_species[[x]]) <- c(x,"Taxonomic_ID")
kraken2_files_filter_species[[x]]
})
names(Hives_species) <- names(kraken2_files_filter_species)
Hives_family <- lapply(names(kraken2_files_filter_family), function(x){
colnames(kraken2_files_filter_family[[x]]) <- c(x,"Taxonomic_ID")
kraken2_files_filter_family[[x]]
})
names(Hives_family) <- names(kraken2_files_filter_family)
# The functions below collapse the list into a single data frame and all NA values are adjusted to 0
Hives_comparison_genus <- Hives_genus %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.),0))
Hives_comparison_species <- Hives_species %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))
Hives_comparison_family <- Hives_family %>% purrr::reduce(full_join, by = "Taxonomic_ID") %>% select("Taxonomic_ID", everything()) %>% mutate_all(~replace(., is.na(.), 0))
# Before we proceed with normalisation we create a function for taxonomic classification before we export the normalised reads
# Classification function for the DESeq2 object to export the normalised reads
classification_deseq_export <- function(normalised_reads, path_filename) {
df <- normalised_reads %>% round(.,digits=0) %>% as.data.frame() %>% rownames_to_column(var = "Taxonomic_ID")
taxids <- df$Taxonomic_ID
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum",'nameNode.sqlite'))
Superkingdom <- as.character(getTaxonomy(taxids, desiredTaxa = "superkingdom",'nameNode.sqlite'))
Kingdom <- as.character(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Class <- as.character(getTaxonomy(taxids, desiredTaxa = "class", 'nameNode.sqlite'))
Order <- as.character(getTaxonomy(taxids, desiredTaxa = "order", 'nameNode.sqlite'))
Family <- as.character(getTaxonomy(taxids,desiredTaxa = "family", 'nameNode.sqlite'))
Genus <- as.character(getTaxonomy(taxids,desiredTaxa = "genus", 'nameNode.sqlite'))
Species <- as.character(getTaxonomy(taxids,desiredTaxa = "species", sqlFile = 'nameNode.sqlite'))
df_export <- cbind(df, Superkingdom, Kingdom, Phylum, Class, Order, Family, Genus, Species)
write.csv(df_export, file = path_filename)
}
# Normalisation with DESeq2 requires a metadata file
hives_metadata <- read.csv("./Figures/Figure_3/Data_fig_3/metadata_hives.csv")
# We apply the RLE normalisation but using the Method + Season so we can observe seasonal effects and do methodological validation
Hives_dds_family <- DESeqDataSetFromMatrix(countData = Hives_comparison_family, colData = hives_metadata, design = ~Method + Season, tidy = TRUE)
Hives_dds_RLE_family <- estimateSizeFactors(Hives_dds_family,type = "ratio")
kraken2_files = lapply(kraken2_files,arrange, Taxonomic_ID)
# We will add the classification information. Plase note that this will take a little while to generate so be patient!
classification_ranks <- function(df) {
taxids <- df[,4]
Phylum <- as.character(getTaxonomy(taxids, desiredTaxa = "phylum", 'nameNode.sqlite'))
Kingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "kingdom", 'nameNode.sqlite'))
Superkingdom <- as.data.frame(getTaxonomy(taxids, desiredTaxa = "superkingdom", 'nameNode.sqlite'))
cbind(df, Phylum, Kingdom, Superkingdom)
}
kraken2_files = lapply(kraken2_files, classification_ranks)
kraken2_files = lapply(kraken2_files, classification_ranks)
kraken2_files = lapply(kraken2_files, classification_ranks)
# draw volcano plots
get_volcano_plot <- function(dds_rle_object, contrast, annotation) {
object <- DESeq(dds_rle_object)
res_dds <- results(object, contrast)
res <- lfcShrink(object,contrast = contrast, res=res_dds,type = 'normal')
annotations <- annotation %>% rownames_to_column(var = "Taxonomic_ID")
annotations$Taxonomic_ID <- as.numeric(annotations$Taxonomic_ID)
EnhancedVolcano(res, lab = NA, x = 'log2FoldChange',y= 'pvalue', FCcutoff = 1,
colAlpha = 2,labSize = 2, xlim = c(-2,2))
}
# These MA plots are made using the methods as contrasts to observe effects due to method
family_volcano_plot <- get_volcano_plot(Hives_dds_RLE_family, contrast = c('Method','Direct_SM','SM'), annotation = Taxid_taxonomy_family)
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('here')) install.packages('here'); library('here')
if (!require('pheatmap')) install.packages('pheatmap'); library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
if (!require("reshape2")) install.packages("reshape2"); library('reshape2')
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('VennDiagram')) install.packages('VennDiagram'); library('VennDiagram')
# Load or install (if not present) the required packages
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('purrr')) install.packages('purrr'); library('purrr')
if (!require('here')) install.packages('here'); library('here')
if (!require('pheatmap')) install.packages('pheatmap'); library('pheatmap')
if (!require('EnhancedVolcano')) BiocManager::install('EnhancedVolcano'): library('EnhancedVolcano')
if (!require("DEGreport")) BiocManager::install("DEGreport"): library('DEGreport')
if (!require("reshape2")) install.packages("reshape2"); library('reshape2')
if (!require('DESeq2')) install.packages('DESeq2'); library('DESeq2')
if (!require('VennDiagram')) install.packages('VennDiagram'); library('VennDiagram')
df_humann <- read.table('./Figures/Figure_7/go_annotation_notnorm.tsv',
row.names=1, header=T, sep='\t',
comment.char='', quote='')
# Remove the suffix from the sample labels
names(df_humann) <- gsub('_Abundance.RPKs', '', names(df_humann))
hives_metadata <- read.csv("./Figures/Figure_3/Data_fig_3/metadata_hives.csv")
hives_metadata_new <- hives_metadata %>% column_to_rownames(var="X")
View(hives_metadata)
View(hives_metadata_new)
family_sig_res <- sig_res_LRT(Hives_dds_RLE_family, meta = hives_metadata_new)
# Now we can cluster the significantly abundant families/genera/species and observe patterns
sig_res_LRT <- function(dds_object1, meta) {
dds_object2 <- DESeq(dds_object1, test = "LRT", reduced = ~Method, full = ~Method+Season)
res_LRT <- results(dds_object2)
sig <- res_LRT %>% data.frame() %>% rownames_to_column(var="Taxonomic_ID") %>% as_tibble() %>%  filter(padj < 0.05)
clustering <- sig %>% arrange(padj) %>% head(n=1000)
rld <- rlog(dds_object2, blind = F)
rld_mat <- assay(rld)
cluster_rlog <- cluster_rlog <- rld_mat[clustering$Taxonomic_ID, ]
meta$Method <- c("DirectSM","DirectSM","DirectSM","DirectSM","SM","SM","SM","SM")
results_deg <- degPatterns(cluster_rlog, metadata = meta, time = "Season", col="Method", minc = 3)
degPlotCluster(results_deg$normalized, time = "Season", color = "Method", facet = T) + theme_bw() + scale_x_discrete(limits = c("May","July","November")) + scale_colour_viridis_d() + labs(title = "", y = "Z-score of abundance")
}
df_humann2 <- round(df_humann, digits = 0)
Hives_dds_functional <- DESeqDataSetFromMatrix(countData = df_humann2, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_functional <- estimateSizeFactors(Hives_dds_functional,type = "ratio")
Hives_normalised_counts_functional <- counts(Hives_dds_RLE_functional, normalized = TRUE)
Hives_dds_functional <- DESeqDataSetFromMatrix(countData = df_humann2, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_functional <- estimateSizeFactors(Hives_dds_functional,type = "ratio")
Hives_normalised_counts_functional <- counts(Hives_dds_RLE_functional, normalized = TRUE)
Hives_counts_vst_functional <- varianceStabilizingTransformation(Hives_dds_RLE_functional, blind = FALSE)
ordered_counts_functional <- order(rowMeans(counts(Hives_dds_RLE_functional,normalized=TRUE)), decreasing=TRUE)
# Draw heatmap of all go functions
final_heatmap_functional <- pheatmap(assay(Hives_counts_vst_functional)[ordered_counts_functional,],cluster_rows = FALSE, show_rownames = FALSE, clustering_distance_cols = "correlation", cluster_cols = TRUE)
# Volcano plot to evaluate whether some differ by method
get_volcano_plot <- function(dds_rle_object, .contrast) {
object <- DESeq(dds_rle_object,test = "LRT", reduced = ~Method, full = ~Method+Season)
res_dds <- results(object, .contrast)
res <- lfcShrink(object,contrast = .contrast, res=res_dds,type = 'normal')
EnhancedVolcano(res, lab = NA, x = 'log2FoldChange',y= 'pvalue', FCcutoff = 1,
colAlpha = 2,labSize = 2, xlim = c(-2,2))
}
get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Method','SM','Direct_SM'))
# By season
get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Season','May','November'))
# Calculate difference between SM and DSM for each hive individually
df_humann_matrix <- as.data.frame(matrix_humann2)
Hive_4_fun <- df_humann_matrix$DSM_H4 - df_humann_matrix$SM_H4
Hive_5_fun <- df_humann_matrix$DSM_H5 - df_humann_matrix$SM_H5
Hive_6_fun <- df_humann_matrix$DSM_H6 - df_humann_matrix$SM_H6
Hive_7_fun <- df_humann_matrix$DSM_H7 - df_humann_matrix$SM_H7
df_humann2 <- round(df_humann, digits = 0)
Hives_dds_functional <- DESeqDataSetFromMatrix(countData = df_humann2, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
df_humann <- read.table('./Figures/Figure_7/go_annotation_notnorm.tsv',
row.names=1, header=T, sep='\t',
comment.char='', quote='')
# Remove the suffix from the sample labels
names(df_humann) <- gsub('_Abundance.RPKs', '', names(df_humann))
hives_metadata <- read.csv("./Figures/Figure_3/Data_fig_3/metadata_hives.csv")
hives_metadata_new <- hives_metadata %>% column_to_rownames(var="X")
df_humann2 <- round(df_humann, digits = 0)
Hives_dds_functional <- DESeqDataSetFromMatrix(countData = df_humann2, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_functional <- estimateSizeFactors(Hives_dds_functional,type = "ratio")
Hives_normalised_counts_functional <- counts(Hives_dds_RLE_functional, normalized = TRUE)
Hives_counts_vst_functional <- varianceStabilizingTransformation(Hives_dds_RLE_functional, blind = FALSE)
ordered_counts_functional <- order(rowMeans(counts(Hives_dds_RLE_functional,normalized=TRUE)), decreasing=TRUE)
# Draw heatmap of all go functions
final_heatmap_functional <- pheatmap(assay(Hives_counts_vst_functional)[ordered_counts_functional,],cluster_rows = FALSE, show_rownames = FALSE, clustering_distance_cols = "correlation", cluster_cols = TRUE)
# Volcano plot to evaluate whether some differ by method
get_volcano_plot <- function(dds_rle_object, .contrast) {
object <- DESeq(dds_rle_object,test = "LRT", reduced = ~Method, full = ~Method+Season)
res_dds <- results(object, .contrast)
res <- lfcShrink(object,contrast = .contrast, res=res_dds,type = 'normal')
EnhancedVolcano(res, lab = NA, x = 'log2FoldChange',y= 'pvalue', FCcutoff = 1,
colAlpha = 2,labSize = 2, xlim = c(-2,2))
}
get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Method','SM','Direct_SM'))
# By season
get_volcano_plot(Hives_dds_RLE_functional, .contrast = c('Season','May','November'))
# Calculate difference between SM and DSM for each hive individually
df_humann_matrix <- as.data.frame(matrix_humann2)
Hive_4_fun <- df_humann_matrix$DSM_H4 - df_humann_matrix$SM_H4
Hive_5_fun <- df_humann_matrix$DSM_H5 - df_humann_matrix$SM_H5
Hive_6_fun <- df_humann_matrix$DSM_H6 - df_humann_matrix$SM_H6
Hive_7_fun <- df_humann_matrix$DSM_H7 - df_humann_matrix$SM_H7
differences <- as.data.frame(cbind(Hive_4_fun,Hive_5_fun,Hive_6_fun,Hive_7_fun))
differences$pathways <- rownames(df_humann_matrix)
differences_for_boxplot <- melt(differences)
differences_boxplot <-  ggplot(differences_for_boxplot, aes(x=pathways, y=value)) +
geom_boxplot() +
scale_fill_viridis(discrete = TRUE, alpha=0.6) +
geom_jitter(color="black", size=0.4, alpha=0.9) +
theme_minimal() +
theme(
legend.position="none",
plot.title = element_text(size=11),
axis.text.y = element_blank()
) + xlab("") + ylab ("DSM vs SM difference (%)") + coord_flip()
# Per species FUNCTIONAL diversity
go_names <- read.table('./Figures/Figure_7/combined_tables_with_go_names.tsv',
row.names=1, header=T, sep='\t',
comment.char='', quote='')
# Custom function to create dataframe with per species functional diversity so that we can
# later plot it .
species_functional_diversity <- function(normalised_counts) {
go_names_normalised <- as.data.frame(normalised_counts) %>% rownames_to_column(var="species")
go_names_normalised$go_function <- go_names_normalised$species
go_names_normalised$species <- gsub(".*[__]([^.]+)[.].*", "\\1", go_names_normalised$species)
go_names_normalised$go_function <- gsub("\\|.*", "", go_names_normalised$go_function)
go_names_normalised <- go_names_normalised[!grepl("GO:", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNMAPPED", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$go_function),]
}
functional_diversity_samples <- species_functional_diversity(Hives_normalised_counts_go)
# Per species FUNCTIONAL diversity
go_names <- read.table('./Figures/Figure_7/combined_tables_with_go_names.tsv',
row.names=1, header=T, sep='\t',
comment.char='', quote='')
# Remove the suffix from the sample labels
names(go_names) <- gsub('_Abundance.RPKs', '', names(go_names))
go_names_deseq <- round(go_names, digits = 0)
View(go_names_deseq)
Hives_dds_go <- DESeqDataSetFromMatrix(countData = go_names_deseq, colData = hives_metadata_new, design = ~Method + Season, tidy = F)
Hives_dds_RLE_go <- estimateSizeFactors(Hives_dds_go,type = "ratio")
Hives_normalised_counts_go <- counts(Hives_dds_RLE_go, normalized = TRUE)
View(Hives_normalised_counts_functional)
View(Hives_normalised_counts_go)
family_sig_res <- sig_res_LRT(Hives_dds_RLE_family, meta = hives_metadata_new)
genus_sig_res <- sig_res_LRT(Hives_dds_RLE_genus, meta = hives_metadata_new)
species_sig_res <- sig_res_LRT(Hives_dds_RLE_species, meta = hives_metadata_new)
ggsave(plot = family_sig_res, filename = "./Figures/Figure_3/DEGpattern_family.pdf", height = 4)
# Custom function to create dataframe with per species functional diversity so that we can
# later plot it .
species_functional_diversity <- function(normalised_counts) {
go_names_normalised <- as.data.frame(normalised_counts) %>% rownames_to_column(var="species")
go_names_normalised$go_function <- go_names_normalised$species
go_names_normalised$species <- gsub(".*[__]([^.]+)[.].*", "\\1", go_names_normalised$species)
go_names_normalised$go_function <- gsub("\\|.*", "", go_names_normalised$go_function)
go_names_normalised <- go_names_normalised[!grepl("GO:", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNMAPPED", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$species),]
go_names_normalised <- go_names_normalised[!grepl("UNGROUPED", go_names_normalised$go_function),]
}
functional_diversity_samples <- species_functional_diversity(Hives_normalised_counts_go)
View(functional_diversity_samples)
